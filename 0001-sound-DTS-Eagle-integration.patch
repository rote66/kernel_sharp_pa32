From 7118a1b61e07e1bcdcbc987f2243de5d512f365f Mon Sep 17 00:00:00 2001
From: joshuous <joshuous@gmail.com>
Date: Sun, 24 Jun 2018 15:40:03 +0100
Subject: [PATCH] sound: DTS-Eagle integration

Signed-off-by: joshuous <joshuous@gmail.com>
---
 drivers/misc/qcom/qdsp6v2/audio_hwacc_effects.c |   63 +
 include/sound/msm-dts-eagle.h                   |  148 ++
 include/sound/q6adm-v2.h                        |    1 +
 sound/soc/msm/qdsp6v2/Makefile                  |    1 +
 sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c |   29 +-
 sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c      |   76 ++
 sound/soc/msm/qdsp6v2/msm-dts-eagle.c           | 1640 +++++++++++++++++++++++
 sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c   |    1 +
 sound/soc/msm/qdsp6v2/msm-pcm-routing-devdep.c  |   39 +-
 sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c      |   11 +
 sound/soc/msm/qdsp6v2/q6adm.c                   |  257 ++++
 sound/soc/msm/qdsp6v2/q6asm.c                   |  237 ++++
 sound/soc/msm/qdsp6v2/q6core.c                  |  111 +-
 13 files changed, 2608 insertions(+), 6 deletions(-)
 create mode 100644 include/sound/msm-dts-eagle.h
 create mode 100644 sound/soc/msm/qdsp6v2/msm-dts-eagle.c

diff --git a/drivers/misc/qcom/qdsp6v2/audio_hwacc_effects.c b/drivers/misc/qcom/qdsp6v2/audio_hwacc_effects.c
index ebe9ab76..d2f354ae 100644
--- a/drivers/misc/qcom/qdsp6v2/audio_hwacc_effects.c
+++ b/drivers/misc/qcom/qdsp6v2/audio_hwacc_effects.c
@@ -17,6 +17,7 @@
 #include "q6audio_common.h"
 #include "audio_utils_aio.h"
 #include <sound/msm-audio-effects-q6-v2.h>
+#include <sound/msm-dts-eagle.h>
 
 #define MAX_CHANNELS_SUPPORTED		8
 #define WAIT_TIMEDOUT_DURATION_SECS	1
@@ -57,6 +58,32 @@ static void audio_effects_init_pp(struct audio_client *ac)
 	if (ret < 0)
 		pr_err("%s: Send SoftVolume Param failed ret=%d\n",
 			__func__, ret);
+
+	switch (ac->topology) {
+	case ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER:
+
+		ret = q6asm_set_softvolume_v2(ac, &softvol,
+					      SOFT_VOLUME_INSTANCE_1);
+		if (ret < 0)
+			pr_err("%s: Send SoftVolume1 Param failed ret=%d\n",
+				__func__, ret);
+		ret = q6asm_set_softvolume_v2(ac, &softvol,
+					      SOFT_VOLUME_INSTANCE_2);
+		if (ret < 0)
+			pr_err("%s: Send SoftVolume2 Param failed ret=%d\n",
+				 __func__, ret);
+
+		msm_dts_eagle_init_master_module(ac);
+
+		break;
+	default:
+		ret = q6asm_set_softvolume_v2(ac, &softvol,
+					      SOFT_VOLUME_INSTANCE_1);
+		if (ret < 0)
+			pr_err("%s: Send SoftVolume Param failed ret=%d\n",
+				__func__, ret);
+		break;
+	}
 }
 
 static void audio_effects_deinit_pp(struct audio_client *ac)
@@ -65,6 +92,14 @@ static void audio_effects_deinit_pp(struct audio_client *ac)
 		pr_err("%s: audio client null to deinit pp\n", __func__);
 		return;
 	}
+
+	switch (ac->topology) {
+	case ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER:
+		msm_dts_eagle_deinit_master_module(ac);
+		break;
+	default:
+		break;
+	}
 }
 
 static void audio_effects_event_handler(uint32_t opcode, uint32_t token,
@@ -399,6 +434,34 @@ static long audio_effects_set_pp_param(struct q6audio_effects *effects,
 			      &(effects->audio_effects.topo_switch_vol),
 			      (long *)&values[1], SOFT_VOLUME_INSTANCE_2);
 		break;
+
+	case DTS_EAGLE_MODULE_ENABLE:
+		pr_debug("%s: DTS_EAGLE_MODULE_ENABLE\n", __func__);
+		if (msm_audio_effects_is_effmodule_supp_in_top(
+			effects_module, effects->ac->topology)) {
+			/*
+			 * HPX->OFF: first disable HPX and then
+			 * enable SA+
+			 * HPX->ON: first disable SA+ and then
+			 * enable HPX
+			 */
+			bool hpx_state = (bool)values[1];
+			if (hpx_state)
+				msm_audio_effects_enable_extn(effects->ac,
+					&(effects->audio_effects),
+					false);
+			msm_dts_eagle_enable_asm(effects->ac,
+				hpx_state,
+				AUDPROC_MODULE_ID_DTS_HPX_PREMIX);
+			msm_dts_eagle_enable_asm(effects->ac,
+				hpx_state,
+				AUDPROC_MODULE_ID_DTS_HPX_POSTMIX);
+			if (!hpx_state)
+				msm_audio_effects_enable_extn(effects->ac,
+					&(effects->audio_effects),
+					true);
+		}
+		break;
 	default:
 		pr_err("%s: Invalid effects config module\n", __func__);
 		rc = -EINVAL;
diff --git a/include/sound/msm-dts-eagle.h b/include/sound/msm-dts-eagle.h
new file mode 100644
index 00000000..2ef01136
--- /dev/null
+++ b/include/sound/msm-dts-eagle.h
@@ -0,0 +1,148 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MSM_DTS_EAGLE_H__
+#define __MSM_DTS_EAGLE_H__
+
+#include <linux/compat.h>
+#include <sound/soc.h>
+#include <sound/devdep_params.h>
+#include <sound/q6asm-v2.h>
+
+#ifdef CONFIG_COMPAT
+enum {
+	DTS_EAGLE_IOCTL_GET_CACHE_SIZE32 = _IOR(0xF2, 0, __s32),
+	DTS_EAGLE_IOCTL_SET_CACHE_SIZE32 = _IOW(0xF2, 1, __s32),
+	DTS_EAGLE_IOCTL_GET_PARAM32 = _IOR(0xF2, 2, compat_uptr_t),
+	DTS_EAGLE_IOCTL_SET_PARAM32 = _IOW(0xF2, 3, compat_uptr_t),
+	DTS_EAGLE_IOCTL_SET_CACHE_BLOCK32 =
+				_IOW(0xF2, 4, compat_uptr_t),
+	DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE32 =
+				_IOW(0xF2, 5, compat_uptr_t),
+	DTS_EAGLE_IOCTL_GET_LICENSE32 =
+				_IOR(0xF2, 6, compat_uptr_t),
+	DTS_EAGLE_IOCTL_SET_LICENSE32 =
+				 _IOW(0xF2, 7, compat_uptr_t),
+	DTS_EAGLE_IOCTL_SEND_LICENSE32 = _IOW(0xF2, 8, __s32),
+	DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS32 = _IOW(0xF2, 9,
+						     compat_uptr_t),
+};
+#endif
+
+#ifdef CONFIG_DTS_EAGLE
+void msm_dts_ion_memmap(struct param_outband *po_);
+int msm_dts_eagle_enable_asm(struct audio_client *ac, u32 enable, int module);
+int msm_dts_eagle_enable_adm(int port_id, int copp_idx, u32 enable);
+void msm_dts_eagle_add_controls(struct snd_soc_platform *platform);
+int msm_dts_eagle_set_stream_gain(struct audio_client *ac,
+				  int lgain, int rgain);
+int msm_dts_eagle_handle_asm(struct dts_eagle_param_desc *depd, char *buf,
+			     bool for_pre, bool get, struct audio_client *ac,
+			     struct param_outband *po);
+int msm_dts_eagle_handle_adm(struct dts_eagle_param_desc *depd, char *buf,
+			     bool for_pre, bool get);
+int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg);
+int msm_dts_eagle_is_hpx_on(void);
+int msm_dts_eagle_init_pre(struct audio_client *ac);
+int msm_dts_eagle_deinit_pre(struct audio_client *ac);
+int msm_dts_eagle_init_post(int port_id, int copp_id);
+int msm_dts_eagle_deinit_post(int port_id, int topology);
+int msm_dts_eagle_init_master_module(struct audio_client *ac);
+int msm_dts_eagle_deinit_master_module(struct audio_client *ac);
+int msm_dts_eagle_pcm_new(struct snd_soc_pcm_runtime *runtime);
+void msm_dts_eagle_pcm_free(struct snd_pcm *pcm);
+int msm_dts_eagle_compat_ioctl(unsigned int cmd, unsigned long arg);
+#else
+static inline void msm_dts_ion_memmap(struct param_outband *po_)
+{
+	pr_debug("%s\n", __func__);
+}
+static inline int msm_dts_eagle_enable_asm(struct audio_client *ac,
+					   u32 enable, int module)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_enable_adm(int port_id, int copp_idx,
+					   u32 enable)
+{
+	return 0;
+}
+static inline void msm_dts_eagle_add_controls(struct snd_soc_platform *platform)
+{
+}
+static inline int msm_dts_eagle_set_stream_gain(struct audio_client *ac,
+						int lgain, int rgain)
+{
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+static inline int msm_dts_eagle_handle_asm(struct dts_eagle_param_desc *depd,
+					   char *buf, bool for_pre, bool get,
+					   struct audio_client *ac,
+					   struct param_outband *po)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_handle_adm(struct dts_eagle_param_desc *depd,
+					   char *buf, bool for_pre, bool get)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
+{
+	return -EPERM;
+}
+static inline int msm_dts_eagle_is_hpx_on(void)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_init_pre(struct audio_client *ac)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_deinit_pre(struct audio_client *ac)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_init_post(int port_id, int coppid)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_deinit_post(int port_id, int topology)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_init_master_module(struct audio_client *ac)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_deinit_master_module(struct audio_client *ac)
+{
+	return 0;
+}
+static inline int msm_dts_eagle_pcm_new(struct snd_soc_pcm_runtime *runtime)
+{
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+static inline void msm_dts_eagle_pcm_free(struct snd_pcm *pcm)
+{
+	pr_debug("%s\n", __func__);
+}
+static inline int msm_dts_eagle_compat_ioctl(unsigned int cmd,
+					unsigned long arg)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/include/sound/q6adm-v2.h b/include/sound/q6adm-v2.h
index 7d0f08fc..c3638978 100644
--- a/include/sound/q6adm-v2.h
+++ b/include/sound/q6adm-v2.h
@@ -34,6 +34,7 @@ enum {
 	ADM_AUDVOL_CAL,
 	ADM_RTAC_INFO_CAL,
 	ADM_RTAC_APR_CAL,
+	ADM_DTS_EAGLE,
 	ADM_SRS_TRUMEDIA,
 	ADM_RTAC_AUDVOL_CAL,
 	ADM_MAX_CAL_TYPES
diff --git a/sound/soc/msm/qdsp6v2/Makefile b/sound/soc/msm/qdsp6v2/Makefile
index 7abaaadc..e402b69d 100644
--- a/sound/soc/msm/qdsp6v2/Makefile
+++ b/sound/soc/msm/qdsp6v2/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_SLIMBUS) += msm-dai-slim.o audio_slimslave.o
 obj-$(CONFIG_SND_SOC_QDSP6V2) += snd-soc-qdsp6v2.o msm-pcm-dtmf-v2.o \
 				 msm-dai-stub-v2.o
 obj-$(CONFIG_SND_HWDEP) += msm-pcm-routing-devdep.o
+obj-$(CONFIG_DTS_EAGLE) += msm-dts-eagle.o
 obj-$(CONFIG_DOLBY_DAP) += msm-dolby-dap-config.o
 obj-$(CONFIG_DOLBY_DS2) += msm-ds2-dap-config.o
 obj-$(CONFIG_DTS_SRS_TM) += msm-dts-srs-tm-config.o
diff --git a/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c
index 1286d318..7ed02c3a 100644
--- a/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c
@@ -15,6 +15,7 @@
 #include <sound/q6asm-v2.h>
 #include <sound/compress_params.h>
 #include <sound/msm-audio-effects-q6-v2.h>
+#include <sound/msm-dts-eagle.h>
 #include <sound/devdep_params.h>
 
 #define MAX_ENABLE_CMD_SIZE 32
@@ -48,6 +49,26 @@ bool msm_audio_effects_is_effmodule_supp_in_top(int effect_module,
 	case EQ_MODULE:
 		switch (topology) {
 		case ASM_STREAM_POSTPROC_TOPO_ID_SA_PLUS:
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_PLUS:
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER:
+			return true;
+		default:
+			return false;
+		}
+	case DTS_EAGLE_MODULE:
+		switch (topology) {
+		case ASM_STREAM_POSTPROC_TOPO_ID_DTS_HPX:
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_PLUS:
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER:
+			return true;
+		default:
+			return false;
+		}
+	case SOFT_VOLUME2_MODULE:
+	case DTS_EAGLE_MODULE_ENABLE:
+		switch (topology) {
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_PLUS:
+		case ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER:
 			return true;
 		default:
 			return false;
@@ -255,7 +276,7 @@ int msm_audio_effects_virtualizer_handler(struct audio_client *ac,
 			break;
 		}
 	}
-	if (params_length && (rc == 0))
+	if (params_length && !msm_dts_eagle_is_hpx_on() && (rc == 0))
 		q6asm_send_audio_effects_params(ac, params,
 						params_length);
 	else
@@ -726,7 +747,7 @@ int msm_audio_effects_reverb_handler(struct audio_client *ac,
 			break;
 		}
 	}
-	if (params_length && (rc == 0))
+	if (params_length && !msm_dts_eagle_is_hpx_on() && (rc == 0))
 		q6asm_send_audio_effects_params(ac, params,
 						params_length);
 	else
@@ -862,7 +883,7 @@ int msm_audio_effects_bass_boost_handler(struct audio_client *ac,
 			break;
 		}
 	}
-	if (params_length && (rc == 0))
+	if (params_length && !msm_dts_eagle_is_hpx_on() && (rc == 0))
 		q6asm_send_audio_effects_params(ac, params,
 						params_length);
 	else
@@ -1202,7 +1223,7 @@ int msm_audio_effects_popless_eq_handler(struct audio_client *ac,
 			break;
 		}
 	}
-	if (params_length && (rc == 0))
+	if (params_length && !msm_dts_eagle_is_hpx_on() && (rc == 0))
 		q6asm_send_audio_effects_params(ac, params,
 						params_length);
 	else
diff --git a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
index fdd30cad..4c9fb0b1 100644
--- a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
@@ -42,6 +42,8 @@
 #include <sound/compress_offload.h>
 #include <sound/compress_driver.h>
 #include <sound/msm-audio-effects-q6-v2.h>
+#include <sound/msm-dts-eagle.h>
+
 #include "msm-pcm-routing-v2.h"
 
 #define DSP_PP_BUFFERING_IN_MSEC	25
@@ -84,6 +86,15 @@ const DECLARE_TLV_DB_LINEAR(msm_compr_vol_gain, 0,
 
 #define MAX_NUMBER_OF_STREAMS 2
 
+/*
+ * Max size for getting DTS EAGLE Param through kcontrol
+ * Safe for both 32 and 64 bit platforms
+ * 64 = size of kcontrol value array on 64 bit platform
+ * 4 = size of parameters Eagle expects before cast to 64 bits
+ * 40 = size of dts_eagle_param_desc + module_id cast to 64 bits
+ */
+#define DTS_EAGLE_MAX_PARAM_SIZE_FOR_ALSA ((64 * 4) - 40)
+
 //use 24bits to get rid of 16bits innate noise
 int gis_24bits = 0;
 struct msm_compr_gapless_state {
@@ -283,6 +294,11 @@ static int msm_compr_set_volume(struct snd_compr_stream *cstream,
 	if (rc < 0)
 		pr_err("%s: Send vol gain command failed rc=%d\n",
 		       __func__, rc);
+	else
+		if (msm_dts_eagle_set_stream_gain(prtd->audio_client,
+						volume_l, volume_r))
+			pr_debug("%s: DTS_EAGLE send stream gain failed\n",
+				__func__);
 
 	return rc;
 }
@@ -1043,6 +1059,26 @@ static int msm_compr_init_pp_params(struct snd_compr_stream *cstream,
 	};
 
 	switch (ac->topology) {
+	case ASM_STREAM_POSTPROC_TOPO_ID_HPX_PLUS: /* HPX + SA+ topology */
+
+		ret = q6asm_set_softvolume_v2(ac, &softvol,
+					      SOFT_VOLUME_INSTANCE_1);
+		if (ret < 0)
+			pr_err("%s: Send SoftVolume Param failed ret=%d\n",
+			__func__, ret);
+
+		ret = q6asm_set_softvolume_v2(ac, &softvol,
+					      SOFT_VOLUME_INSTANCE_2);
+		if (ret < 0)
+			pr_err("%s: Send SoftVolume2 Param failed ret=%d\n",
+			__func__, ret);
+		/*
+		 * HPX module init is trigerred from HAL using ioctl
+		 * DTS_EAGLE_MODULE_ENABLE when stream starts
+		 */
+		break;
+	case ASM_STREAM_POSTPROC_TOPO_ID_DTS_HPX: /* HPX topology */
+		break;
 	default:
 		ret = q6asm_set_softvolume_v2(ac, &softvol,
 					      SOFT_VOLUME_INSTANCE_1);
@@ -2920,6 +2956,23 @@ static int msm_compr_audio_effects_config_put(struct snd_kcontrol *kcontrol,
 						    &(audio_effects->equalizer),
 						     values);
 		break;
+	case DTS_EAGLE_MODULE:
+		pr_debug("%s: DTS_EAGLE_MODULE\n", __func__);
+		if (!msm_audio_effects_is_effmodule_supp_in_top(effects_module,
+						prtd->audio_client->topology))
+			return 0;
+		msm_dts_eagle_handle_asm(NULL, (void *)values, true,
+					 false, prtd->audio_client, NULL);
+		break;
+	case DTS_EAGLE_MODULE_ENABLE:
+		pr_debug("%s: DTS_EAGLE_MODULE_ENABLE\n", __func__);
+		if (msm_audio_effects_is_effmodule_supp_in_top(effects_module,
+						prtd->audio_client->topology))
+			msm_dts_eagle_enable_asm(prtd->audio_client,
+					(bool)values[0],
+					AUDPROC_MODULE_ID_DTS_HPX_PREMIX);
+
+		break;
 	case SOFT_VOLUME_MODULE:
 		pr_debug("%s: SOFT_VOLUME_MODULE\n", __func__);
 		break;
@@ -2948,6 +3001,7 @@ static int msm_compr_audio_effects_config_get(struct snd_kcontrol *kcontrol,
 	struct msm_compr_audio_effects *audio_effects = NULL;
 	struct snd_compr_stream *cstream = NULL;
 	struct msm_compr_audio *prtd = NULL;
+	long *values = &(ucontrol->value.integer.value[0]);
 
 	pr_debug("%s\n", __func__);
 	if (fe_id >= MSM_FRONTEND_DAI_MAX) {
@@ -2970,6 +3024,28 @@ static int msm_compr_audio_effects_config_get(struct snd_kcontrol *kcontrol,
 		return -EINVAL;
 	}
 
+	switch (audio_effects->query.mod_id) {
+	case DTS_EAGLE_MODULE:
+		pr_debug("%s: DTS_EAGLE_MODULE handling queued get\n",
+			 __func__);
+		values[0] = (long)audio_effects->query.mod_id;
+		values[1] = (long)audio_effects->query.parm_id;
+		values[2] = (long)audio_effects->query.size;
+		values[3] = (long)audio_effects->query.offset;
+		values[4] = (long)audio_effects->query.device;
+		if (values[2] > DTS_EAGLE_MAX_PARAM_SIZE_FOR_ALSA) {
+			pr_err("%s: DTS_EAGLE_MODULE parameter's requested size (%li) too large (max size is %i)\n",
+				__func__, values[2],
+				DTS_EAGLE_MAX_PARAM_SIZE_FOR_ALSA);
+			return -EINVAL;
+		}
+		msm_dts_eagle_handle_asm(NULL, (void *)&values[1],
+					 true, true, prtd->audio_client, NULL);
+		break;
+	default:
+		pr_err("%s: Invalid effects config module\n", __func__);
+		return -EINVAL;
+	}
 	return 0;
 }
 
diff --git a/sound/soc/msm/qdsp6v2/msm-dts-eagle.c b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
new file mode 100644
index 00000000..ae0ae33b
--- /dev/null
+++ b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
@@ -0,0 +1,1640 @@
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/msm_ion.h>
+#include <linux/mm.h>
+#include <linux/msm_audio_ion.h>
+#include <linux/vmalloc.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/q6adm-v2.h>
+#include <sound/q6asm-v2.h>
+#include <sound/apr_audio-v2.h>
+#include <sound/q6audio-v2.h>
+#include <sound/audio_effects.h>
+#include <sound/hwdep.h>
+#include <sound/msm-dts-eagle.h>
+#include <sound/q6core.h>
+
+#include "msm-pcm-routing-v2.h"
+
+#define ION_MEM_SIZE  131072
+#define DEPC_MAX_SIZE 524288
+
+#define MPST				AUDPROC_MODULE_ID_DTS_HPX_POSTMIX
+#define MPRE				AUDPROC_MODULE_ID_DTS_HPX_PREMIX
+
+#define eagle_vol_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_VOLUME: " fmt "\n", ##__VA_ARGS__)
+#define eagle_vol_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_VOLUME: " fmt "\n", ##__VA_ARGS__)
+#define eagle_drv_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER: " fmt "\n", ##__VA_ARGS__)
+#define eagle_drv_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER: " fmt "\n", ##__VA_ARGS__)
+#define eagle_precache_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_PRE: " fmt "\n", ##__VA_ARGS__)
+#define eagle_precache_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_SENDCACHE_PRE: " fmt "\n", ##__VA_ARGS__)
+#define eagle_postcache_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_POST: " fmt "\n", ##__VA_ARGS__)
+#define eagle_postcache_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: " fmt "\n", ##__VA_ARGS__)
+#define eagle_ioctl_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_IOCTL: " fmt "\n", ##__VA_ARGS__)
+#define eagle_ioctl_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_IOCTL: " fmt "\n", ##__VA_ARGS__)
+#define eagle_asm_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_ASM: " fmt "\n", ##__VA_ARGS__)
+#define eagle_asm_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_ASM: " fmt "\n", ##__VA_ARGS__)
+#define eagle_adm_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_DRIVER_ADM: " fmt "\n", ##__VA_ARGS__)
+#define eagle_adm_err(fmt, ...) \
+	pr_err("DTS_EAGLE_DRIVER_ADM: " fmt "\n", ##__VA_ARGS__)
+#define eagle_enable_dbg(fmt, ...) \
+	pr_debug("DTS_EAGLE_ENABLE: " fmt "\n", ##__VA_ARGS__)
+#define eagle_enable_err(fmt, ...) \
+	pr_err("DTS_EAGLE_ENABLE: " fmt "\n", ##__VA_ARGS__)
+#define eagle_ioctl_info(fmt, ...) \
+	pr_err("DTS_EAGLE_IOCTL: " fmt "\n", ##__VA_ARGS__)
+
+enum {
+	AUDIO_DEVICE_OUT_EARPIECE = 0,
+	AUDIO_DEVICE_OUT_SPEAKER,
+	AUDIO_DEVICE_OUT_WIRED_HEADSET,
+	AUDIO_DEVICE_OUT_WIRED_HEADPHONE,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER,
+	AUDIO_DEVICE_OUT_AUX_DIGITAL,
+	AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET,
+	AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET,
+	AUDIO_DEVICE_OUT_USB_ACCESSORY,
+	AUDIO_DEVICE_OUT_USB_DEVICE,
+	AUDIO_DEVICE_OUT_REMOTE_SUBMIX,
+	AUDIO_DEVICE_OUT_ANC_HEADSET,
+	AUDIO_DEVICE_OUT_ANC_HEADPHONE,
+	AUDIO_DEVICE_OUT_PROXY,
+	AUDIO_DEVICE_OUT_FM,
+	AUDIO_DEVICE_OUT_FM_TX,
+
+	AUDIO_DEVICE_OUT_COUNT
+};
+
+#define AUDIO_DEVICE_COMBO 0x400000 /* bit 23 */
+
+enum { /* cache block */
+	CB_0 = 0,
+	CB_1,
+	CB_2,
+	CB_3,
+	CB_4,
+	CB_5,
+	CB_6,
+	CB_7,
+
+	CB_COUNT
+};
+
+enum { /* cache block description */
+	CBD_DEV_MASK = 0,
+	CBD_OFFSG,
+	CBD_CMD0,
+	CBD_SZ0,
+	CBD_OFFS1,
+	CBD_CMD1,
+	CBD_SZ1,
+	CBD_OFFS2,
+	CBD_CMD2,
+	CBD_SZ2,
+	CBD_OFFS3,
+	CBD_CMD3,
+	CBD_SZ3,
+
+	CBD_COUNT,
+};
+
+static s32 _fx_logN(s32 x)
+{
+	s32 t, y = 0xa65af;
+	if (x < 0x00008000) {
+		x <<= 16; y -= 0xb1721; }
+	if (x < 0x00800000) {
+		x <<= 8; y -= 0x58b91; }
+	if (x < 0x08000000) {
+		x <<= 4; y -= 0x2c5c8; }
+	if (x < 0x20000000) {
+		x <<= 2; y -= 0x162e4; }
+	if (x < 0x40000000) {
+		x <<= 1; y -= 0x0b172; }
+	t = x + (x >> 1);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x067cd; }
+	t = x + (x >> 2);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x03920; }
+	t = x + (x >> 3);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x01e27; }
+	t = x + (x >> 4);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x00f85; }
+	t = x + (x >> 5);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x007e1; }
+	t = x + (x >> 6);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x003f8; }
+	t = x + (x >> 7);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x001fe; }
+	x = 0x80000000 - x;
+	y -= x >> 15;
+	return y;
+}
+
+static inline void *_getd(struct dts_eagle_param_desc *depd)
+{
+	return (void *)(((char *)depd) + sizeof(struct dts_eagle_param_desc));
+}
+
+static int _ref_cnt;
+/* dts eagle parameter cache */
+static char *_depc;
+static u32 _depc_size;
+static s32 _c_bl[CB_COUNT][CBD_COUNT];
+static u32 _device_primary;
+static u32 _device_all;
+/* ION states */
+static struct ion_client *_ion_client;
+static struct ion_handle *_ion_handle;
+static struct param_outband _po;
+static struct audio_client *_ac_NT;
+static struct ion_client *_ion_client_NT;
+static struct ion_handle *_ion_handle_NT;
+static struct param_outband _po_NT;
+
+#define SEC_BLOB_MAX_CNT 10
+#define SEC_BLOB_MAX_SIZE 0x4004 /*extra 4 for size*/
+static char *_sec_blob[SEC_BLOB_MAX_CNT];
+struct mutex _sec_lock;
+
+/* multi-copp support */
+static int _cidx[AFE_MAX_PORTS] = {-1};
+
+/* volume controls */
+#define VOL_CMD_CNT_MAX 10
+static u32 _vol_cmd_cnt;
+static s32 **_vol_cmds;
+struct vol_cmds_d {
+	s32 d[4];
+};
+static struct vol_cmds_d *_vol_cmds_d;
+static const s32 _log10_10_inv_x20 = 0x0008af84;
+
+/* hpx master control */
+static u32 _is_hpx_enabled;
+
+static void _volume_cmds_free(void)
+{
+	int i;
+	for (i = 0; i < _vol_cmd_cnt; i++)
+		kfree(_vol_cmds[i]);
+	_vol_cmd_cnt = 0;
+	kfree(_vol_cmds);
+	kfree(_vol_cmds_d);
+	_vol_cmds = NULL;
+	_vol_cmds_d = NULL;
+}
+
+static s32 _volume_cmds_alloc1(s32 size)
+{
+	_volume_cmds_free();
+	_vol_cmd_cnt = size;
+	_vol_cmds = kzalloc(_vol_cmd_cnt * sizeof(int *), GFP_KERNEL);
+	if (_vol_cmds) {
+		_vol_cmds_d = kzalloc(_vol_cmd_cnt * sizeof(struct vol_cmds_d),
+					GFP_KERNEL);
+	}
+	if (_vol_cmds_d)
+		return 0;
+	_volume_cmds_free();
+	return -ENOMEM;
+}
+
+/* assumes size is equal or less than 0xFFF */
+static s32 _volume_cmds_alloc2(s32 idx, s32 size)
+{
+	kfree(_vol_cmds[idx]);
+	_vol_cmds[idx] = kzalloc(size, GFP_KERNEL);
+	if (_vol_cmds[idx])
+		return 0;
+	_vol_cmds_d[idx].d[0] = 0;
+	return -ENOMEM;
+}
+
+static void _init_cb_descs(void)
+{
+	int i;
+	for (i = 0; i < CB_COUNT; i++) {
+		_c_bl[i][CBD_DEV_MASK] = 0;
+		_c_bl[i][CBD_OFFSG] = _c_bl[i][CBD_OFFS1] =
+		_c_bl[i][CBD_OFFS2] = _c_bl[i][CBD_OFFS3] =
+		0xFFFFFFFF;
+		_c_bl[i][CBD_CMD0] = _c_bl[i][CBD_SZ0] =
+		_c_bl[i][CBD_CMD1] = _c_bl[i][CBD_SZ1] =
+		_c_bl[i][CBD_CMD2] = _c_bl[i][CBD_SZ2] =
+		_c_bl[i][CBD_CMD3] = _c_bl[i][CBD_SZ3] = 0;
+	}
+}
+
+static u32 _get_dev_mask_for_pid(int pid)
+{
+	switch (pid) {
+	case SLIMBUS_0_RX:
+		return (1 << AUDIO_DEVICE_OUT_EARPIECE) |
+			(1 << AUDIO_DEVICE_OUT_SPEAKER) |
+			(1 << AUDIO_DEVICE_OUT_WIRED_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_WIRED_HEADPHONE) |
+			(1 << AUDIO_DEVICE_OUT_ANC_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_ANC_HEADPHONE);
+	case INT_BT_SCO_RX:
+		return (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT);
+	case RT_PROXY_PORT_001_RX:
+		return (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER) |
+			(1 << AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_USB_ACCESSORY) |
+			(1 << AUDIO_DEVICE_OUT_USB_DEVICE) |
+			(1 << AUDIO_DEVICE_OUT_PROXY);
+	case HDMI_RX:
+		return 1 << AUDIO_DEVICE_OUT_AUX_DIGITAL;
+	case INT_FM_RX:
+		return 1 << AUDIO_DEVICE_OUT_FM;
+	case INT_FM_TX:
+		return 1 << AUDIO_DEVICE_OUT_FM_TX;
+	default:
+		return 0;
+	}
+}
+
+static int _get_pid_from_dev(u32 device)
+{
+	if (device & (1 << AUDIO_DEVICE_OUT_EARPIECE) ||
+	    device & (1 << AUDIO_DEVICE_OUT_SPEAKER) ||
+	    device & (1 << AUDIO_DEVICE_OUT_WIRED_HEADSET) ||
+	    device & (1 << AUDIO_DEVICE_OUT_WIRED_HEADPHONE) ||
+	    device & (1 << AUDIO_DEVICE_OUT_ANC_HEADSET) ||
+	    device & (1 << AUDIO_DEVICE_OUT_ANC_HEADPHONE)) {
+		return SLIMBUS_0_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT)) {
+		return INT_BT_SCO_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER) ||
+		   device & (1 << AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_USB_ACCESSORY) ||
+		   device & (1 << AUDIO_DEVICE_OUT_USB_DEVICE) ||
+		   device & (1 << AUDIO_DEVICE_OUT_PROXY)) {
+		return RT_PROXY_PORT_001_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_AUX_DIGITAL)) {
+		return HDMI_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_FM)) {
+		return INT_FM_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_FM_TX)) {
+		return INT_FM_TX;
+	}
+	return 0;
+}
+
+static s32 _get_cb_for_dev(int device)
+{
+	s32 i;
+	if (device & AUDIO_DEVICE_COMBO) {
+		for (i = 0; i < CB_COUNT; i++) {
+			if ((_c_bl[i][CBD_DEV_MASK] & device) == device)
+				return i;
+		}
+	} else {
+		for (i = 0; i < CB_COUNT; i++) {
+			if ((_c_bl[i][CBD_DEV_MASK] & device) &&
+			    !(_c_bl[i][CBD_DEV_MASK] & AUDIO_DEVICE_COMBO))
+				return i;
+		}
+	}
+	eagle_drv_err("%s: device %i not found", __func__, device);
+	return -EINVAL;
+}
+
+static int _is_port_open_and_eagle(int pid)
+{
+	if (msm_routing_check_backend_enabled(pid))
+		return 1;
+	return 1;
+}
+
+static int _isNTDevice(u32 device)
+{
+	if (device &
+		((1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO) |
+		(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET) |
+		(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) |
+		(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP) |
+		(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES) |
+		(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER) |
+		(1 << AUDIO_DEVICE_OUT_AUX_DIGITAL)))
+		return 1;
+	return 0;
+}
+
+static void _reg_ion_mem(void)
+{
+	int rc;
+	rc = msm_audio_ion_alloc("DTS_EAGLE", &_ion_client, &_ion_handle,
+			    ION_MEM_SIZE, &_po.paddr, &_po.size, &_po.kvaddr);
+	if (rc)
+		eagle_drv_err("%s: msm audio ion alloc failed with %i",
+				__func__, rc);
+}
+
+static void _unreg_ion_mem(void)
+{
+	int rc;
+	rc = msm_audio_ion_free(_ion_client, _ion_handle);
+	if (rc)
+		eagle_drv_err("%s: msm audio ion alloc failed with %i",
+				__func__, rc);
+}
+
+static void _reg_ion_mem_NT(void)
+{
+	int rc;
+	eagle_drv_dbg("%s: NT ion mem", __func__);
+	rc = msm_audio_ion_alloc("DTS_EAGLE", &_ion_client_NT,
+				 &_ion_handle_NT, ION_MEM_SIZE,
+				 &_po_NT.paddr, &_po_NT.size, &_po_NT.kvaddr);
+	if (rc) {
+		eagle_drv_err("%s: msm audio ion alloc failed",	__func__);
+		return;
+	}
+	rc = q6asm_memory_map(_ac_NT, _po_NT.paddr,
+			      IN, _po_NT.size, 1);
+	if (rc < 0) {
+		eagle_drv_err("%s: memory map failed", __func__);
+		msm_audio_ion_free(_ion_client_NT, _ion_handle_NT);
+		_ion_client_NT = NULL;
+		_ion_handle_NT = NULL;
+	}
+}
+
+static void _unreg_ion_mem_NT(void)
+{
+	int rc;
+	rc = q6asm_memory_unmap(_ac_NT,	_po_NT.paddr, IN);
+	if (rc < 0)
+		eagle_drv_err("%s: mem unmap failed", __func__);
+	rc = msm_audio_ion_free(_ion_client_NT, _ion_handle_NT);
+	if (rc < 0)
+		eagle_drv_err("%s: mem free failed", __func__);
+
+	_ion_client_NT = NULL;
+	_ion_handle_NT = NULL;
+}
+
+static struct audio_client *_getNTDeviceAC(void)
+{
+	return _ac_NT;
+}
+
+static void _set_audioclient(struct audio_client *ac)
+{
+	_ac_NT = ac;
+	_reg_ion_mem_NT();
+}
+
+static void _clear_audioclient(void)
+{
+	_unreg_ion_mem_NT();
+	_ac_NT = NULL;
+}
+
+
+static int _sendcache_pre(struct audio_client *ac)
+{
+	uint32_t offset, size;
+	int32_t cidx, cmd, err = 0;
+	cidx = _get_cb_for_dev(_device_primary);
+	if (cidx < 0) {
+		eagle_precache_err("%s: no cache for primary device %i found",
+			__func__, _device_primary);
+		return -EINVAL;
+	}
+	offset = _c_bl[cidx][CBD_OFFSG];
+	cmd = _c_bl[cidx][CBD_CMD0];
+	size = _c_bl[cidx][CBD_SZ0];
+	/* check for integer overflow */
+	if (offset > (UINT_MAX - size))
+		err = -EINVAL;
+	if ((_depc_size == 0) || !_depc || (size == 0) ||
+		cmd == 0 || ((offset + size) > _depc_size) || (err != 0)) {
+		eagle_precache_err("%s: primary device %i cache index %i general error - cache size = %u, cache ptr = %pK, offset = %u, size = %u, cmd = %i",
+			__func__, _device_primary, cidx, _depc_size, _depc,
+			offset, size, cmd);
+		return -EINVAL;
+	}
+
+	if ((offset < (UINT_MAX - 124)) && ((offset + 124) < _depc_size))
+		eagle_precache_dbg("%s: first 6 integers %i %i %i %i %i %i (30th %i)",
+			__func__, *((int *)&_depc[offset]),
+			*((int *)&_depc[offset+4]),
+			*((int *)&_depc[offset+8]),
+			*((int *)&_depc[offset+12]),
+			*((int *)&_depc[offset+16]),
+			*((int *)&_depc[offset+20]),
+			*((int *)&_depc[offset+120]));
+	eagle_precache_dbg("%s: sending full data block to port, with cache index = %d device mask 0x%X, param = 0x%X, offset = %u, and size = %u",
+		  __func__, cidx, _c_bl[cidx][CBD_DEV_MASK], cmd, offset, size);
+
+	if (q6asm_dts_eagle_set(ac, cmd, size, (void *)&_depc[offset],
+				NULL, MPRE))
+		eagle_precache_err("%s: q6asm_dts_eagle_set failed with id = %d and size = %u",
+			__func__, cmd, size);
+	else
+		eagle_precache_dbg("%s: q6asm_dts_eagle_set succeeded with id = %d and size = %u",
+			 __func__, cmd, size);
+	return 0;
+}
+
+static int _sendcache_post(int port_id, int copp_idx, int topology)
+{
+	int cidx = -1, cmd, mask, index, err = 0;
+	uint32_t offset, size;
+
+	if (port_id == -1) {
+		cidx = _get_cb_for_dev(_device_primary);
+		if (cidx < 0) {
+			eagle_postcache_err("%s: no cache for primary device %i found. Port id was 0x%X",
+				__func__, _device_primary, port_id);
+			return -EINVAL;
+		}
+		goto NT_MODE_GOTO;
+	}
+
+	index = adm_validate_and_get_port_index(port_id);
+	if (index < 0) {
+		eagle_postcache_err("%s: Invalid port idx %d port_id %#x",
+			__func__, index, port_id);
+		return -EINVAL;
+	}
+	eagle_postcache_dbg("%s: valid port idx %d for port_id %#x set to %i",
+		__func__, index, port_id, copp_idx);
+	_cidx[index] = copp_idx;
+
+	mask = _get_dev_mask_for_pid(port_id);
+	if (mask & _device_primary) {
+		cidx = _get_cb_for_dev(_device_primary);
+		if (cidx < 0) {
+			eagle_postcache_err("%s: no cache for primary device %i found. Port id was 0x%X",
+				__func__, _device_primary, port_id);
+			return -EINVAL;
+		}
+	} else if (mask & _device_all) {
+		cidx = _get_cb_for_dev(_device_all);
+		if (cidx < 0) {
+			eagle_postcache_err("%s: no cache for combo device %i found. Port id was 0x%X",
+				__func__, _device_all, port_id);
+			return -EINVAL;
+		}
+	} else {
+		eagle_postcache_err("%s: port id 0x%X not for primary or combo device %i",
+			__func__, port_id, _device_primary);
+		return -EINVAL;
+	}
+
+NT_MODE_GOTO:
+	offset = _c_bl[cidx][CBD_OFFSG] + _c_bl[cidx][CBD_OFFS2];
+	cmd = _c_bl[cidx][CBD_CMD2];
+	size = _c_bl[cidx][CBD_SZ2];
+
+	/* check for integer overflow */
+	if (offset > (UINT_MAX - size))
+		err = -EINVAL;
+	if ((_depc_size == 0) || !_depc || (err != 0) || (size == 0) ||
+		(cmd == 0) || (offset + size) > _depc_size) {
+		eagle_postcache_err("%s: primary device %i cache index %i port_id 0x%X general error - cache size = %u, cache ptr = %pK, offset = %u, size = %u, cmd = %i",
+			__func__, _device_primary, cidx, port_id,
+			_depc_size, _depc, offset, size, cmd);
+		return -EINVAL;
+	}
+
+	if ((offset < (UINT_MAX - 24)) && ((offset + 24) < _depc_size))
+		eagle_postcache_dbg("%s: first 6 integers %i %i %i %i %i %i",
+			__func__, *((int *)&_depc[offset]),
+			*((int *)&_depc[offset+4]),
+			*((int *)&_depc[offset+8]),
+			*((int *)&_depc[offset+12]),
+			*((int *)&_depc[offset+16]),
+			*((int *)&_depc[offset+20]));
+	eagle_postcache_dbg("%s: sending full data block to port, with cache index = %d device mask 0x%X, port_id = 0x%X, param = 0x%X, offset = %u, and size = %u",
+		__func__, cidx, _c_bl[cidx][CBD_DEV_MASK], port_id, cmd,
+		offset, size);
+
+	if (_ac_NT) {
+		eagle_postcache_dbg("%s: NT Route detected", __func__);
+		if (q6asm_dts_eagle_set(_getNTDeviceAC(), cmd, size,
+					(void *)&_depc[offset],
+					&_po_NT, MPST))
+			eagle_postcache_err("%s: q6asm_dts_eagle_set failed with id = 0x%X and size = %u",
+				__func__, cmd, size);
+	} else if (adm_dts_eagle_set(port_id, copp_idx, cmd,
+			      (void *)&_depc[offset], size) < 0)
+		eagle_postcache_err("%s: adm_dts_eagle_set failed with id = 0x%X and size = %u",
+			__func__, cmd, size);
+	else
+		eagle_postcache_dbg("%s: adm_dts_eagle_set succeeded with id = 0x%X and size = %u",
+			 __func__, cmd, size);
+	return 0;
+}
+
+static int _enable_post_get_control(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = _is_hpx_enabled;
+	return 0;
+}
+
+static int _enable_post_put_control(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	int idx = 0, be_index = 0, port_id, topology;
+	int flag = ucontrol->value.integer.value[0];
+	struct msm_pcm_routing_bdai_data msm_bedai;
+	eagle_drv_dbg("%s: flag %d", __func__, flag);
+
+	_is_hpx_enabled = flag ? true : false;
+	msm_pcm_routing_acquire_lock();
+	/* send cache postmix params when hpx is set On */
+	for (be_index = 0; be_index < MSM_BACKEND_DAI_MAX; be_index++) {
+		msm_pcm_routing_get_bedai_info(be_index, &msm_bedai);
+		port_id = msm_bedai.port_id;
+		if (!(((port_id == SLIMBUS_0_RX) ||
+		      (port_id == RT_PROXY_PORT_001_RX)) &&
+		      msm_bedai.active))
+			continue;
+		for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++) {
+			topology = adm_get_topology_for_port_copp_idx(
+								port_id, idx);
+			if (topology ==
+				ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX) {
+				msm_dts_eagle_enable_adm(port_id, idx,
+							 _is_hpx_enabled);
+			}
+		}
+	}
+	msm_pcm_routing_release_lock();
+	return 0;
+}
+
+static const struct snd_kcontrol_new _hpx_enabled_controls[] = {
+	SOC_SINGLE_EXT("Set HPX OnOff", SND_SOC_NOPM, 0, 1, 0,
+	_enable_post_get_control, _enable_post_put_control)
+};
+
+/**
+ * msm_dts_ion_memmap() - helper function to map ION memory
+ * @po_:	Out of band memory structure used as memory.
+ *
+ * Assign already allocated ION memory for mapping it to dsp.
+ *
+ * Return: No return value.
+ */
+void msm_dts_ion_memmap(struct param_outband *po_)
+{
+	po_->size = ION_MEM_SIZE;
+	po_->kvaddr = _po.kvaddr;
+	po_->paddr = _po.paddr;
+}
+
+/**
+ * msm_dts_eagle_enable_asm() - Enable/disable dts module
+ * @ac:	Enable/disable module in ASM session associated with this audio client.
+ * @enable:	Enable/disable the dts module.
+ * @module:	module id.
+ *
+ * Enable/disable specified dts module id in asm.
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_enable_asm(struct audio_client *ac, u32 enable, int module)
+{
+	int ret = 0;
+	eagle_enable_dbg("%s: enable = %i on module %i",
+		 __func__, enable, module);
+	_is_hpx_enabled = enable;
+	ret = q6asm_dts_eagle_set(ac, AUDPROC_PARAM_ID_ENABLE,
+				      sizeof(enable), &enable,
+				      NULL, module);
+	if (_is_hpx_enabled) {
+		if (module == MPRE)
+			_sendcache_pre(ac);
+		else if (module == MPST)
+			_sendcache_post(-1, 0, 0);
+	}
+	return ret;
+}
+
+/**
+ * msm_dts_eagle_enable_adm() - Enable/disable dts module in adm
+ * @port_id:	Send enable/disable param to this port id.
+ * @copp_idx:	Send enable/disable param to the relevant copp.
+ * @enable:	Enable/disable the dts module.
+ *
+ * Enable/disable dts module in adm.
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_enable_adm(int port_id, int copp_idx, u32 enable)
+{
+	int ret = 0;
+	eagle_enable_dbg("%s: enable = %i", __func__, enable);
+	_is_hpx_enabled = enable;
+	ret = adm_dts_eagle_set(port_id, copp_idx, AUDPROC_PARAM_ID_ENABLE,
+			     (char *)&enable, sizeof(enable));
+	if (_is_hpx_enabled)
+		_sendcache_post(port_id, copp_idx, MPST);
+	return ret;
+}
+
+/**
+ * msm_dts_eagle_add_controls() -  Add mixer control to Enable/Disable DTS HPX
+ * @platform:	Add mixer controls to this platform.
+ *
+ * Add mixer control to Enable/Disable DTS HPX module in ADM.
+ *
+ * Return: No return value.
+ */
+void msm_dts_eagle_add_controls(struct snd_soc_platform *platform)
+{
+	snd_soc_add_platform_controls(platform, _hpx_enabled_controls,
+				      ARRAY_SIZE(_hpx_enabled_controls));
+}
+
+/**
+ * msm_dts_eagle_set_stream_gain() -  Set stream gain to DTS Premix module
+ * @ac:	Set stream gain to ASM session associated with this audio client.
+ * @lgain:	Left gain value.
+ * @rgain:	Right gain value.
+ *
+ * Set stream gain to DTS Premix module in ASM.
+ *
+ * Return: failure or success.
+ */
+int msm_dts_eagle_set_stream_gain(struct audio_client *ac, int lgain, int rgain)
+{
+	u32 i, val;
+	s32 idx, err = 0;
+
+	eagle_vol_dbg("%s: - entry: vol_cmd_cnt = %u, lgain = %i, rgain = %i",
+		 __func__, _vol_cmd_cnt, lgain, rgain);
+
+	if (_depc_size == 0) {
+		eagle_vol_dbg("%s: driver cache not initialized", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < _vol_cmd_cnt; i++) {
+		if (_vol_cmds_d[i].d[0] & 0x8000) {
+			idx = (sizeof(struct dts_eagle_param_desc)/sizeof(int))
+				+ (_vol_cmds_d[i].d[0] & 0x3FF);
+			val = _fx_logN(((s32)(lgain+rgain)) << 2);
+			val = ((long long)val * _log10_10_inv_x20) >> 16;
+			_vol_cmds[i][idx] = (s32)clamp((int)(((long long)val *
+						    _vol_cmds_d[i].d[1]) >> 16),
+						    _vol_cmds_d[i].d[2],
+						    _vol_cmds_d[i].d[3]);
+			 eagle_vol_dbg("%s: loop %u cmd desc found %i, idx = %i. volume info: lgain = %i, rgain = %i, volume = %i (scale %i, min %i, max %i)",
+				 __func__, i, _vol_cmds_d[i].d[0], idx, lgain,
+				 rgain, _vol_cmds[i][idx], _vol_cmds_d[i].d[1],
+				 _vol_cmds_d[i].d[2], _vol_cmds_d[i].d[3]);
+		}
+		idx = _get_cb_for_dev(_device_primary);
+		if (idx < 0) {
+			eagle_vol_err("%s: no cache for primary device %i found",
+				__func__, _device_primary);
+			return -EINVAL;
+		}
+		val = _c_bl[idx][CBD_OFFSG] + _vol_cmds[i][2];
+		/* check for integer overflow */
+		if (val > (UINT_MAX - _vol_cmds[i][1]))
+			err = -EINVAL;
+		if ((err != 0) || ((val + _vol_cmds[i][1]) > _depc_size)) {
+			eagle_vol_err("%s: volume size (%u) + offset (%i) out of bounds %i",
+				__func__, val, _vol_cmds[i][1], _depc_size);
+			return -EINVAL;
+		}
+		memcpy((void *)&_depc[val], &_vol_cmds[i][4], _vol_cmds[i][1]);
+		if (q6asm_dts_eagle_set(ac, _vol_cmds[i][0],
+			_vol_cmds[i][1], (void *)&_depc[val], NULL, MPRE))
+			eagle_vol_err("%s: loop %u - volume set failed with id 0x%X, size %i, offset %i, cmd_desc %i, scale %i, min %i, max %i, data(...) %i",
+				__func__, i, _vol_cmds[i][0], _vol_cmds[i][1],
+				_vol_cmds[i][2], _vol_cmds_d[i].d[0],
+				_vol_cmds_d[i].d[1], _vol_cmds_d[i].d[2],
+				_vol_cmds_d[i].d[3], _vol_cmds[i][4]);
+		else
+			eagle_vol_dbg("%s: loop %u - volume set succeeded with id 0x%X, size %i, offset %i, cmd_desc %i, scale %i, min %i, max %i, data(...) %i",
+				 __func__, i, _vol_cmds[i][0], _vol_cmds[i][1],
+				 _vol_cmds[i][2], _vol_cmds_d[i].d[0],
+				 _vol_cmds_d[i].d[1], _vol_cmds_d[i].d[2],
+				 _vol_cmds_d[i].d[3], _vol_cmds[i][4]);
+	}
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_handle_asm() - Set or Get params from ASM
+ * @depd:	DTS Eagle Params structure.
+ * @buf:	Buffer to get queried param value.
+ * @for_pre:	For premix module or postmix module.
+ * @get:	Getting param from DSP or setting param.
+ * @ac:	Set/Get from ASM session associated with this audio client.
+ * @po:	Out of band memory to set or get postmix params.
+ *
+ * Set or Get params from modules in ASM session.
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_handle_asm(struct dts_eagle_param_desc *depd, char *buf,
+			     bool for_pre, bool get, struct audio_client *ac,
+			     struct param_outband *po)
+{
+	struct dts_eagle_param_desc depd_ = {0};
+	s32 ret = 0, isALSA = 0, err = 0, i, mod = for_pre ? MPRE : MPST;
+	u32 offset;
+
+	eagle_asm_dbg("%s: set/get asm", __func__);
+
+	/* special handling for ALSA route, to accommodate 64 bit platforms */
+	if (depd == NULL) {
+		long *arg_ = (long *)buf;
+		depd = &depd_;
+		depd->id = (u32)*arg_++;
+		depd->size = (u32)*arg_++;
+		depd->offset = (s32)*arg_++;
+		depd->device = (u32)*arg_++;
+		buf = (char *)arg_;
+		isALSA = 1;
+	}
+
+	if (depd->size & 1) {
+		eagle_asm_err("%s: parameter size %u is not a multiple of 2",
+			__func__, depd->size);
+		return -EINVAL;
+	}
+
+	if (get) {
+		void *buf_, *buf_m = NULL;
+		eagle_asm_dbg("%s: get requested", __func__);
+		if (depd->offset == -1) {
+			eagle_asm_dbg("%s: get from dsp requested", __func__);
+			if (depd->size > 0 && depd->size <= DEPC_MAX_SIZE) {
+				buf_ = buf_m = vzalloc(depd->size);
+			} else {
+				eagle_asm_err("%s: get size %u invalid",
+					      __func__, depd->size);
+				return -EINVAL;
+			}
+			if (!buf_m) {
+				eagle_asm_err("%s: out of memory", __func__);
+				return -ENOMEM;
+			} else if (q6asm_dts_eagle_get(ac, depd->id,
+						       depd->size, buf_m,
+						       po, mod) < 0) {
+				eagle_asm_err("%s: asm get failed", __func__);
+				ret = -EFAULT;
+				goto DTS_EAGLE_IOCTL_GET_PARAM_PRE_EXIT;
+			}
+			eagle_asm_dbg("%s: get result: param id 0x%x value %d size %u",
+				 __func__, depd->id, *(int *)buf_m, depd->size);
+		} else {
+			s32 tgt = _get_cb_for_dev(depd->device);
+			if (tgt < 0) {
+				eagle_asm_err("%s: no cache for device %u found",
+					__func__, depd->device);
+				return -EINVAL;
+			}
+			offset = _c_bl[tgt][CBD_OFFSG] + depd->offset;
+			/* check for integer overflow */
+			if (offset > (UINT_MAX - depd->size))
+				err = -EINVAL;
+			if ((err != 0) || (offset + depd->size) > _depc_size) {
+				eagle_asm_err("%s: invalid size %u and/or offset %u",
+					__func__, depd->size, offset);
+				return -EINVAL;
+			}
+			buf_ = (u32 *)&_depc[offset];
+		}
+		if (isALSA) {
+			if (depd->size == 2) {
+				*(long *)buf = (long)*(__u16 *)buf_;
+				eagle_asm_dbg("%s: asm out 16 bit value %li",
+						__func__, *(long *)buf);
+			} else {
+				s32 *pbuf = (s32 *)buf_;
+				long *bufl = (long *)buf;
+				for (i = 0; i < (depd->size >> 2); i++) {
+					*bufl++ = (long)*pbuf++;
+					eagle_asm_dbg("%s: asm out value %li",
+							 __func__, *(bufl-1));
+				}
+			}
+		} else {
+			memcpy(buf, buf_, depd->size);
+		}
+DTS_EAGLE_IOCTL_GET_PARAM_PRE_EXIT:
+		vfree(buf_m);
+		return (int)ret;
+	} else {
+		s32 tgt = _get_cb_for_dev(depd->device);
+		if (tgt < 0) {
+			eagle_asm_err("%s: no cache for device %u found",
+				__func__, depd->device);
+			return -EINVAL;
+		}
+		offset = _c_bl[tgt][CBD_OFFSG] + depd->offset;
+		/* check for integer overflow */
+		if (offset > (UINT_MAX - depd->size))
+			err = -EINVAL;
+		if ((err != 0) || ((offset + depd->size) > _depc_size)) {
+			eagle_asm_err("%s: invalid size %u and/or offset %u for parameter (cache is size %u)",
+				__func__, depd->size, offset, _depc_size);
+			return -EINVAL;
+		}
+		if (isALSA) {
+			if (depd->size == 2) {
+				*(__u16 *)&_depc[offset] = (__u16)*(long *)buf;
+				eagle_asm_dbg("%s: asm in 16 bit value %li",
+						__func__, *(long *)buf);
+			} else {
+				s32 *pbuf = (s32 *)&_depc[offset];
+				long *bufl = (long *)buf;
+				for (i = 0; i < (depd->size >> 2); i++) {
+					*pbuf++ = (s32)*bufl++;
+					eagle_asm_dbg("%s: asm in value %i",
+							__func__, *(pbuf-1));
+				}
+			}
+		} else {
+			memcpy(&_depc[offset], buf, depd->size);
+		}
+		eagle_asm_dbg("%s: param info: param = 0x%X, size = %u, offset = %i, device = %u, cache block %i, global offset = %u, first bytes as integer = %i",
+			__func__, depd->id, depd->size, depd->offset,
+			depd->device,
+			tgt, offset, *(int *)&_depc[offset]);
+		if (q6asm_dts_eagle_set(ac, depd->id, depd->size,
+					(void *)&_depc[offset], po, mod))
+			eagle_asm_err("%s: q6asm_dts_eagle_set failed with id = 0x%X, size = %u, offset = %d",
+				__func__, depd->id, depd->size, depd->offset);
+		else
+			eagle_asm_dbg("%s: q6asm_dts_eagle_set succeeded with id = 0x%X, size = %u, offset = %d",
+				 __func__, depd->id, depd->size, depd->offset);
+	}
+	return (int)ret;
+}
+
+/**
+ * msm_dts_eagle_handle_adm() - Set or Get params from ADM
+ * @depd:	DTS Eagle Params structure used to set or get.
+ * @buf:	Buffer to get queried param value in NT mode.
+ * @for_pre:	For premix module or postmix module.
+ * @get:	Getting param from DSP or setting param.
+ *
+ * Set or Get params from modules in ADM session.
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_handle_adm(struct dts_eagle_param_desc *depd, char *buf,
+			     bool for_pre, bool get)
+{
+	u32 pid = _get_pid_from_dev(depd->device), cidx;
+	s32 ret = 0;
+
+	eagle_adm_dbg("%s: set/get adm", __func__);
+
+	if (_isNTDevice(depd->device)) {
+		eagle_adm_dbg("%s: NT Route detected", __func__);
+		ret = msm_dts_eagle_handle_asm(depd, buf, for_pre, get,
+					       _getNTDeviceAC(), &_po_NT);
+		if (ret < 0)
+			eagle_adm_err("%s: NT Route set failed with id = 0x%X, size = %u, offset = %i, device = %u",
+				__func__, depd->id, depd->size, depd->offset,
+				depd->device);
+	} else if (get) {
+		cidx = adm_validate_and_get_port_index(pid);
+		eagle_adm_dbg("%s: get from qdsp requested (port id 0x%X)",
+			 __func__, pid);
+		if (adm_dts_eagle_get(pid, _cidx[cidx], depd->id,
+				      buf, depd->size) < 0) {
+			eagle_adm_err("%s: get from qdsp via adm with port id 0x%X failed",
+				 __func__, pid);
+			return -EFAULT;
+		}
+	} else if (_is_port_open_and_eagle(pid)) {
+		cidx = adm_validate_and_get_port_index(pid);
+		eagle_adm_dbg("%s: adm_dts_eagle_set called with id = 0x%X, size = %u, offset = %i, device = %u, port id = %u, copp index = %u",
+				__func__, depd->id, depd->size, depd->offset,
+				depd->device, pid, cidx);
+		ret = adm_dts_eagle_set(pid, _cidx[cidx], depd->id,
+					(void *)buf, depd->size);
+		if (ret < 0)
+			eagle_adm_err("%s: adm_dts_eagle_set failed", __func__);
+		else
+			eagle_adm_dbg("%s: adm_dts_eagle_set succeeded",
+				__func__);
+	} else {
+		ret = -EINVAL;
+		eagle_adm_dbg("%s: port id 0x%X not active or not Eagle",
+			 __func__, pid);
+	}
+	return (int)ret;
+}
+
+/**
+ * msm_dts_eagle_ioctl() - ioctl handler function
+ * @cmd:	cmd to handle.
+ * @arg:	argument to the cmd.
+ *
+ * Handle DTS Eagle ioctl cmds.
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
+{
+	s32 ret = 0;
+	switch (cmd) {
+	case DTS_EAGLE_IOCTL_GET_CACHE_SIZE: {
+		eagle_ioctl_info("%s: called with control 0x%X (get param cache size)",
+			__func__, cmd);
+		if (copy_to_user((void *)arg, &_depc_size,
+				 sizeof(_depc_size))) {
+			eagle_ioctl_err("%s: error writing size", __func__);
+			return -EFAULT;
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE: {
+		u32 size = 0;
+		eagle_ioctl_info("%s: called with control 0x%X (allocate param cache)",
+			__func__, cmd);
+		if (copy_from_user((void *)&size, (void *)arg, sizeof(size))) {
+			eagle_ioctl_err("%s: error copying size (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &size, sizeof(size));
+			return -EFAULT;
+		} else if (size > DEPC_MAX_SIZE) {
+			eagle_ioctl_err("%s: cache size %u not allowed (min 0, max %u)",
+				__func__, size, DEPC_MAX_SIZE);
+			return -EINVAL;
+		}
+		if (_depc) {
+			eagle_ioctl_dbg("%s: previous param cache of size %u freed",
+				__func__, _depc_size);
+			_depc_size = 0;
+			vfree(_depc);
+			_depc = NULL;
+		}
+		if (size)
+			_depc = vzalloc(size);
+		else
+			eagle_ioctl_dbg("%s: %u bytes requested for param cache, nothing allocated",
+				__func__, size);
+		if (_depc) {
+			eagle_ioctl_dbg("%s: %u bytes allocated for param cache",
+				__func__, size);
+			_depc_size = size;
+		} else {
+			eagle_ioctl_err("%s: error allocating param cache (vzalloc failed on %u bytes)",
+				__func__, size);
+			_depc_size = 0;
+			return -ENOMEM;
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_GET_PARAM: {
+		struct dts_eagle_param_desc depd;
+		s32 for_pre = 0, get_from_core = 0, err = 0;
+		u32 offset;
+		void *buf, *buf_m = NULL;
+		eagle_ioctl_info("%s: control 0x%X (get param)",
+			__func__, cmd);
+		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
+			eagle_ioctl_err("%s: error copying dts_eagle_param_desc (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &depd, sizeof(depd));
+			return -EFAULT;
+		}
+		if (depd.device & DTS_EAGLE_FLAG_IOCTL_PRE) {
+			eagle_ioctl_dbg("%s: using for premix", __func__);
+			for_pre = 1;
+		}
+		if (depd.device & DTS_EAGLE_FLAG_IOCTL_GETFROMCORE) {
+			eagle_ioctl_dbg("%s: 'get from core' requested",
+				__func__);
+			get_from_core = 1;
+			depd.offset = -1;
+		}
+		depd.device &= DTS_EAGLE_FLAG_IOCTL_MASK;
+		if (depd.offset == -1) {
+			if (depd.size > 0 && depd.size <= DEPC_MAX_SIZE) {
+				buf = buf_m = vzalloc(depd.size);
+			} else {
+				eagle_ioctl_err("%s: get size %u invalid",
+						__func__, depd.size);
+				return -EINVAL;
+			}
+			if (!buf_m) {
+				eagle_ioctl_err("%s: out of memory", __func__);
+				return -ENOMEM;
+			}
+			if (get_from_core)
+				ret = core_dts_eagle_get(depd.id, depd.size,
+							 buf);
+			else
+				ret = msm_dts_eagle_handle_adm(&depd, buf,
+								for_pre, true);
+		} else {
+			s32 cb = _get_cb_for_dev(depd.device);
+			if (cb < 0) {
+				eagle_ioctl_err("%s: no cache for device %u found",
+					__func__, depd.device);
+				return -EINVAL;
+			}
+			offset = _c_bl[cb][CBD_OFFSG] + depd.offset;
+			/* check for integer overflow */
+			if (offset > (UINT_MAX - depd.size))
+				err = -EINVAL;
+			if ((err != 0) ||
+			    ((offset + depd.size) > _depc_size)) {
+				eagle_ioctl_err("%s: invalid size %u and/or offset %u",
+					__func__, depd.size, offset);
+				return -EINVAL;
+			}
+			buf = (void *)&_depc[offset];
+		}
+		if (ret < 0)
+			eagle_ioctl_err("%s: error %i getting data", __func__,
+				ret);
+		else if (copy_to_user((void *)(((char *)arg)+sizeof(depd)),
+						  buf, depd.size)) {
+			eagle_ioctl_err("%s: error copying get data", __func__);
+			ret = -EFAULT;
+		}
+		vfree(buf_m);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_PARAM: {
+		struct dts_eagle_param_desc depd;
+		s32 just_set_cache = 0, for_pre = 0, err = 0;
+		u32 offset;
+		s32 tgt;
+		eagle_ioctl_info("%s: control 0x%X (set param)",
+			__func__, cmd);
+		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
+			eagle_ioctl_err("%s: error copying dts_eagle_param_desc (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &depd, sizeof(depd));
+			return -EFAULT;
+		}
+		if (depd.device & DTS_EAGLE_FLAG_IOCTL_PRE) {
+			eagle_ioctl_dbg("%s: using for premix", __func__);
+			for_pre = 1;
+		}
+		if (depd.device & DTS_EAGLE_FLAG_IOCTL_JUSTSETCACHE) {
+			eagle_ioctl_dbg("%s: 'just set cache' requested",
+				__func__);
+			just_set_cache = 1;
+		}
+		depd.device &= DTS_EAGLE_FLAG_IOCTL_MASK;
+		tgt = _get_cb_for_dev(depd.device);
+		if (tgt < 0) {
+			eagle_ioctl_err("%s: no cache for device %u found",
+				__func__, depd.device);
+			return -EINVAL;
+		}
+		offset = _c_bl[tgt][CBD_OFFSG] + depd.offset;
+		/* check for integer overflow */
+		if (offset > (UINT_MAX - depd.size))
+			err = -EINVAL;
+		if ((err != 0) || ((offset + depd.size) > _depc_size)) {
+			eagle_ioctl_err("%s: invalid size %u and/or offset %u for parameter (target cache block %i with offset %i, global cache is size %u)",
+				__func__, depd.size, offset, tgt,
+				_c_bl[tgt][CBD_OFFSG], _depc_size);
+			return -EINVAL;
+		}
+		if (copy_from_user((void *)&_depc[offset],
+				   (void *)(((char *)arg)+sizeof(depd)),
+					depd.size)) {
+			eagle_ioctl_err("%s: error copying param to cache (src:%pK, tgt:%pK, size:%u)",
+				__func__, ((char *)arg)+sizeof(depd),
+				&_depc[offset], depd.size);
+			return -EFAULT;
+		}
+		eagle_ioctl_dbg("%s: param info: param = 0x%X, size = %u, offset = %i, device = %u, cache block %i, global offset = %u, first bytes as integer = %i",
+			__func__, depd.id, depd.size, depd.offset,
+			depd.device, tgt, offset, *(int *)&_depc[offset]);
+		if (!just_set_cache) {
+			ret = msm_dts_eagle_handle_adm(&depd, &_depc[offset],
+						       for_pre, false);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_CACHE_BLOCK: {
+		u32 b_[CBD_COUNT+1], *b = &b_[1], cb;
+		eagle_ioctl_info("%s: with control 0x%X (set param cache block)",
+			 __func__, cmd);
+		if (copy_from_user((void *)b_, (void *)arg, sizeof(b_))) {
+			eagle_ioctl_err("%s: error copying cache block data (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, b_, sizeof(b_));
+			return -EFAULT;
+		}
+		cb = b_[0];
+		if (cb >= CB_COUNT) {
+			eagle_ioctl_err("%s: cache block %u out of range (max %u)",
+				__func__, cb, CB_COUNT-1);
+			return -EINVAL;
+		}
+		eagle_ioctl_dbg("%s: cache block %i set: devices 0x%X, global offset %i, offsets 1:%u 2:%u 3:%u, cmds/sizes 0:0x%X %u 1:0x%X %u 2:0x%X %u 3:0x%X %u",
+		__func__, cb, _c_bl[cb][CBD_DEV_MASK], _c_bl[cb][CBD_OFFSG],
+		_c_bl[cb][CBD_OFFS1], _c_bl[cb][CBD_OFFS2],
+		_c_bl[cb][CBD_OFFS3], _c_bl[cb][CBD_CMD0], _c_bl[cb][CBD_SZ0],
+		_c_bl[cb][CBD_CMD1], _c_bl[cb][CBD_SZ1], _c_bl[cb][CBD_CMD2],
+		_c_bl[cb][CBD_SZ2], _c_bl[cb][CBD_CMD3], _c_bl[cb][CBD_SZ3]);
+		if ((b[CBD_OFFSG]+b[CBD_OFFS1]+b[CBD_SZ1]) > _depc_size ||
+			(b[CBD_OFFSG]+b[CBD_OFFS2]+b[CBD_SZ2]) > _depc_size ||
+			(b[CBD_OFFSG]+b[CBD_OFFS3]+b[CBD_SZ3]) > _depc_size) {
+			eagle_ioctl_err("%s: cache block bounds out of range",
+					__func__);
+			return -EINVAL;
+		}
+		memcpy(_c_bl[cb], b, sizeof(_c_bl[cb]));
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE: {
+		u32 data[2];
+		eagle_ioctl_dbg("%s: with control 0x%X (set active device)",
+			 __func__, cmd);
+		if (copy_from_user((void *)data, (void *)arg, sizeof(data))) {
+			eagle_ioctl_err("%s: error copying active device data (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, data, sizeof(data));
+			return -EFAULT;
+		}
+		if (data[1] != 0) {
+			_device_primary = data[0];
+			eagle_ioctl_dbg("%s: primary device %i", __func__,
+				 data[0]);
+		} else {
+			_device_all = data[0];
+			eagle_ioctl_dbg("%s: all devices 0x%X", __func__,
+				 data[0]);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_GET_LICENSE: {
+		u32 target = 0, size = 0;
+		s32 size_only;
+		eagle_ioctl_dbg("%s: with control 0x%X (get license)",
+			 __func__, cmd);
+		if (copy_from_user((void *)&target, (void *)arg,
+				   sizeof(target))) {
+			eagle_ioctl_err("%s: error reading license index. (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &target, sizeof(target));
+			return -EFAULT;
+		}
+		size_only = target & (1<<31) ? 1 : 0;
+		target &= 0x7FFFFFFF;
+		if (target >= SEC_BLOB_MAX_CNT) {
+			eagle_ioctl_err("%s: license index %u out of bounds (max index is %i)",
+				   __func__, target, SEC_BLOB_MAX_CNT);
+			return -EINVAL;
+		}
+		mutex_lock(&_sec_lock);
+		if (_sec_blob[target] == NULL) {
+			eagle_ioctl_err("%s: license index %u never initialized",
+				   __func__, target);
+			mutex_unlock(&_sec_lock);
+			return -EINVAL;
+		}
+		size = ((u32 *)_sec_blob[target])[0];
+		if ((size == 0) || (size > SEC_BLOB_MAX_SIZE)) {
+			eagle_ioctl_err("%s: license size %u for index %u invalid (min size is 1, max size is %u)",
+				   __func__, size, target, SEC_BLOB_MAX_SIZE);
+			mutex_unlock(&_sec_lock);
+			return -EINVAL;
+		}
+		if (size_only) {
+			eagle_ioctl_dbg("%s: reporting size of license data only",
+					__func__);
+			if (copy_to_user((void *)(((char *)arg)+sizeof(target)),
+				 (void *)&size, sizeof(size))) {
+				eagle_ioctl_err("%s: error copying license size",
+						__func__);
+				mutex_unlock(&_sec_lock);
+				return -EFAULT;
+			}
+		} else if (copy_to_user((void *)(((char *)arg)+sizeof(target)),
+			   (void *)&(((s32 *)_sec_blob[target])[1]), size)) {
+			eagle_ioctl_err("%s: error copying license data",
+				__func__);
+			mutex_unlock(&_sec_lock);
+			return -EFAULT;
+		} else
+			eagle_ioctl_info("%s: license file %u bytes long from license index %u returned to user",
+				  __func__, size, target);
+		mutex_unlock(&_sec_lock);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_LICENSE: {
+		u32 target[2] = {0, 0};
+		eagle_ioctl_dbg("%s: control 0x%X (set license)", __func__,
+				cmd);
+		if (copy_from_user((void *)target, (void *)arg,
+				   sizeof(target))) {
+			eagle_ioctl_err("%s: error reading license index (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, target, sizeof(target));
+			return -EFAULT;
+		}
+		if (target[0] >= SEC_BLOB_MAX_CNT) {
+			eagle_ioctl_err("%s: license index %u out of bounds (max index is %u)",
+				   __func__, target[0], SEC_BLOB_MAX_CNT-1);
+			return -EINVAL;
+		}
+		mutex_lock(&_sec_lock);
+		if (target[1] == 0) {
+			eagle_ioctl_dbg("%s: request to free license index %u",
+				 __func__, target[0]);
+			kfree(_sec_blob[target[0]]);
+			_sec_blob[target[0]] = NULL;
+			mutex_unlock(&_sec_lock);
+			break;
+		}
+		if ((target[1] == 0) || (target[1] >= SEC_BLOB_MAX_SIZE)) {
+			eagle_ioctl_err("%s: license size %u for index %u invalid (min size is 1, max size is %u)",
+				__func__, target[1], target[0],
+				SEC_BLOB_MAX_SIZE);
+			mutex_unlock(&_sec_lock);
+			return -EINVAL;
+		}
+		if (_sec_blob[target[0]] != NULL) {
+			eagle_ioctl_dbg("%s: reallocate already allocated license index %i",
+				 __func__, target[0]);
+			kfree(_sec_blob[target[0]]);
+			_sec_blob[target[0]] = NULL;
+		}
+		eagle_ioctl_dbg("%s: allocating %u bytes for license index %u",
+				__func__, target[1], target[0]);
+		_sec_blob[target[0]] = kzalloc(target[1] + 4, GFP_KERNEL);
+		if (!_sec_blob[target[0]]) {
+			eagle_ioctl_err("%s: error allocating license index %u (kzalloc failed on %u bytes)",
+					__func__, target[0], target[1]);
+			mutex_unlock(&_sec_lock);
+			return -ENOMEM;
+		}
+		((u32 *)_sec_blob[target[0]])[0] = target[1];
+		if (copy_from_user(
+				(void *)&(((u32 *)_sec_blob[target[0]])[1]),
+				(void *)(((char *)arg)+sizeof(target)),
+				target[1])) {
+			eagle_ioctl_err("%s: error copying license to index %u, size %u (src:%pK, tgt:%pK, size:%u)",
+					__func__, target[0], target[1],
+					((char *)arg)+sizeof(target),
+					&(((u32 *)_sec_blob[target[0]])[1]),
+					target[1]);
+			mutex_unlock(&_sec_lock);
+			return -EFAULT;
+		} else
+			eagle_ioctl_info("%s: license file %u bytes long copied to index license index %u",
+				  __func__, target[1], target[0]);
+		mutex_unlock(&_sec_lock);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SEND_LICENSE: {
+		u32 target = 0;
+		eagle_ioctl_dbg("%s: control 0x%X (send license)", __func__,
+				cmd);
+		if (copy_from_user((void *)&target, (void *)arg,
+				   sizeof(target))) {
+			eagle_ioctl_err("%s: error reading license index (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &target, sizeof(target));
+			return -EFAULT;
+		}
+		if (target >= SEC_BLOB_MAX_CNT) {
+			eagle_ioctl_err("%s: license index %u out of bounds (max index is %i)",
+					__func__, target, SEC_BLOB_MAX_CNT-1);
+			return -EINVAL;
+		}
+		mutex_lock(&_sec_lock);
+		if (!_sec_blob[target] ||
+		    ((u32 *)_sec_blob[target])[0] == 0) {
+			eagle_ioctl_err("%s: license index %u is invalid",
+				__func__, target);
+			mutex_unlock(&_sec_lock);
+			return -EINVAL;
+		}
+		if (core_dts_eagle_set(((s32 *)_sec_blob[target])[0],
+				(char *)&((s32 *)_sec_blob[target])[1]) < 0)
+			eagle_ioctl_err("%s: core_dts_eagle_set failed with id = %u",
+				__func__, target);
+		else
+			eagle_ioctl_info("%s: core_dts_eagle_set succeeded with id = %u",
+				 __func__, target);
+		mutex_unlock(&_sec_lock);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS: {
+		s32 spec = 0;
+		eagle_ioctl_info("%s: control 0x%X (set volume commands)",
+				__func__, cmd);
+		if (copy_from_user((void *)&spec, (void *)arg,
+					sizeof(spec))) {
+			eagle_ioctl_err("%s: error reading volume command specifier (src:%pK, tgt:%pK, size:%zu)",
+				__func__, (void *)arg, &spec, sizeof(spec));
+			return -EFAULT;
+		}
+		if (spec & 0x80000000) {
+			u32 idx = (spec & 0x0000F000) >> 12;
+			s32 size = spec & 0x00000FFF;
+			eagle_ioctl_dbg("%s: setting volume command %i size: %i",
+				__func__, idx, size);
+			if (idx >= _vol_cmd_cnt) {
+				eagle_ioctl_err("%s: volume command index %u out of bounds (only %u allocated)",
+					__func__, idx, _vol_cmd_cnt);
+				return -EINVAL;
+			}
+			if (_volume_cmds_alloc2(idx, size) < 0) {
+				eagle_ioctl_err("%s: error allocating memory for volume controls",
+						__func__);
+				return -ENOMEM;
+			}
+			if (copy_from_user((void *)&_vol_cmds_d[idx],
+					(void *)(((char *)arg) + sizeof(int)),
+					sizeof(struct vol_cmds_d))) {
+				eagle_ioctl_err("%s: error reading volume command descriptor (src:%pK, tgt:%pK, size:%zu)",
+					__func__, ((char *)arg) + sizeof(int),
+					&_vol_cmds_d[idx],
+					sizeof(struct vol_cmds_d));
+				return -EFAULT;
+			}
+			eagle_ioctl_dbg("%s: setting volume command %i spec (size %zu): %i %i %i %i",
+				  __func__, idx, sizeof(struct vol_cmds_d),
+				  _vol_cmds_d[idx].d[0], _vol_cmds_d[idx].d[1],
+				  _vol_cmds_d[idx].d[2], _vol_cmds_d[idx].d[3]);
+			if (copy_from_user((void *)_vol_cmds[idx],
+					(void *)(((char *)arg) + (sizeof(int) +
+					sizeof(struct vol_cmds_d))), size)) {
+				eagle_ioctl_err("%s: error reading volume command string (src:%pK, tgt:%pK, size:%i)",
+					__func__, ((char *)arg) + (sizeof(int) +
+					sizeof(struct vol_cmds_d)),
+					_vol_cmds[idx], size);
+				return -EFAULT;
+			}
+		} else {
+			eagle_ioctl_dbg("%s: setting volume command size",
+					__func__);
+			if (spec < 0 || spec > VOL_CMD_CNT_MAX) {
+				eagle_ioctl_err("%s: volume command count %i out of bounds (min 0, max %i)",
+					__func__, spec, VOL_CMD_CNT_MAX);
+				return -EINVAL;
+			} else if (spec == 0) {
+				eagle_ioctl_dbg("%s: request to free volume commands",
+						__func__);
+				_volume_cmds_free();
+				break;
+			}
+			eagle_ioctl_dbg("%s: setting volume command size requested = %i",
+				  __func__, spec);
+			if (_volume_cmds_alloc1(spec) < 0) {
+				eagle_ioctl_err("%s: error allocating memory for volume controls",
+						__func__);
+				return -ENOMEM;
+			}
+		}
+		break;
+	}
+	default: {
+		eagle_ioctl_err("%s: control 0x%X (invalid control)",
+			 __func__, cmd);
+		ret = -EINVAL;
+	}
+	}
+	return (int)ret;
+}
+
+/**
+ * msm_dts_eagle_compat_ioctl() - To handle 32bit to 64bit ioctl compatibility
+ * @cmd:	cmd to handle.
+ * @arg:	argument to the cmd.
+ *
+ * Handle DTS Eagle ioctl cmds from 32bit userspace.
+ *
+ * Return: Return failure if any.
+ */
+#ifdef CONFIG_COMPAT
+int msm_dts_eagle_compat_ioctl(unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case DTS_EAGLE_IOCTL_GET_CACHE_SIZE32:
+		cmd = DTS_EAGLE_IOCTL_GET_CACHE_SIZE;
+		break;
+	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE32:
+		cmd = DTS_EAGLE_IOCTL_SET_CACHE_SIZE;
+		break;
+	case DTS_EAGLE_IOCTL_GET_PARAM32:
+		cmd = DTS_EAGLE_IOCTL_GET_PARAM;
+		break;
+	case DTS_EAGLE_IOCTL_SET_PARAM32:
+		cmd = DTS_EAGLE_IOCTL_SET_PARAM;
+		break;
+	case DTS_EAGLE_IOCTL_SET_CACHE_BLOCK32:
+		cmd = DTS_EAGLE_IOCTL_SET_CACHE_BLOCK;
+		break;
+	case DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE32:
+		cmd = DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE;
+		break;
+	case DTS_EAGLE_IOCTL_GET_LICENSE32:
+		cmd = DTS_EAGLE_IOCTL_GET_LICENSE;
+		break;
+	case DTS_EAGLE_IOCTL_SET_LICENSE32:
+		cmd = DTS_EAGLE_IOCTL_SET_LICENSE;
+		break;
+	case DTS_EAGLE_IOCTL_SEND_LICENSE32:
+		cmd = DTS_EAGLE_IOCTL_SEND_LICENSE;
+		break;
+	case DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS32:
+		cmd = DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS;
+		break;
+	default:
+		break;
+	}
+	return msm_dts_eagle_ioctl(cmd, arg);
+}
+#endif
+/**
+ * msm_dts_eagle_init_pre() - Initialize DTS premix module
+ * @ac:	Initialize premix module in the ASM session.
+ *
+ * Initialize DTS premix module on provided ASM session
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_init_pre(struct audio_client *ac)
+{
+	return msm_dts_eagle_enable_asm(ac, _is_hpx_enabled,
+				 AUDPROC_MODULE_ID_DTS_HPX_PREMIX);
+}
+
+/**
+ * msm_dts_eagle_deinit_pre() - Deinitialize DTS premix module
+ * @ac:	Deinitialize premix module in the ASM session.
+ *
+ * Deinitialize DTS premix module on provided ASM session
+ *
+ * Return: Currently does nothing so 0.
+ */
+int msm_dts_eagle_deinit_pre(struct audio_client *ac)
+{
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_init_post() - Initialize DTS postmix module
+ * @port_id:	Port id for the ADM session.
+ * @copp_idx:	Copp idx for the ADM session.
+ *
+ * Initialize DTS postmix module on ADM session
+ *
+ * Return: Return failure if any.
+ */
+int msm_dts_eagle_init_post(int port_id, int copp_idx)
+{
+	return msm_dts_eagle_enable_adm(port_id, copp_idx, _is_hpx_enabled);
+}
+
+/**
+ * msm_dts_eagle_deinit_post() - Deinitialize DTS postmix module
+ * @port_id:	Port id for the ADM session.
+ * @topology:	Topology in use.
+ *
+ * Deinitialize DTS postmix module on ADM session
+ *
+ * Return: Currently does nothing so 0.
+ */
+int msm_dts_eagle_deinit_post(int port_id, int topology)
+{
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_init_master_module() - Initialize both DTS modules
+ * @ac:	Initialize modules in the ASM session.
+ *
+ * Initialize DTS modules on ASM session
+ *
+ * Return: Success.
+ */
+int msm_dts_eagle_init_master_module(struct audio_client *ac)
+{
+	_set_audioclient(ac);
+	msm_dts_eagle_enable_asm(ac, _is_hpx_enabled,
+				 AUDPROC_MODULE_ID_DTS_HPX_PREMIX);
+	msm_dts_eagle_enable_asm(ac, _is_hpx_enabled,
+				 AUDPROC_MODULE_ID_DTS_HPX_POSTMIX);
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_deinit_master_module() - Deinitialize both DTS modules
+ * @ac:	Deinitialize modules in the ASM session.
+ *
+ * Deinitialize DTS modules on ASM session
+ *
+ * Return: Success.
+ */
+int msm_dts_eagle_deinit_master_module(struct audio_client *ac)
+{
+	msm_dts_eagle_deinit_pre(ac);
+	msm_dts_eagle_deinit_post(-1, 0);
+	_clear_audioclient();
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_is_hpx_on() - Check if HPX effects are On
+ *
+ * Check if HPX effects are On
+ *
+ * Return: On/Off.
+ */
+int msm_dts_eagle_is_hpx_on(void)
+{
+	return _is_hpx_enabled;
+}
+
+/**
+ * msm_dts_eagle_pcm_new() - Create hwdep node
+ * @runtime:	snd_soc_pcm_runtime structure.
+ *
+ * Create hwdep node
+ *
+ * Return: Success.
+ */
+int msm_dts_eagle_pcm_new(struct snd_soc_pcm_runtime *runtime)
+{
+	if (!_ref_cnt++) {
+		_init_cb_descs();
+		_reg_ion_mem();
+	}
+	mutex_init(&_sec_lock);
+	return 0;
+}
+
+/**
+ * msm_dts_eagle_pcm_free() - remove hwdep node
+ * @runtime:	snd_soc_pcm_runtime structure.
+ *
+ * Remove hwdep node
+ *
+ * Return: void.
+ */
+void msm_dts_eagle_pcm_free(struct snd_pcm *pcm)
+{
+	if (!--_ref_cnt)
+		_unreg_ion_mem();
+	vfree(_depc);
+	mutex_destroy(&_sec_lock);
+}
+
+MODULE_DESCRIPTION("DTS EAGLE platform driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c b/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
index 8fc49b29..4677c018 100644
--- a/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
+++ b/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
@@ -20,6 +20,7 @@
 #include <sound/control.h>
 #include <sound/q6adm-v2.h>
 #include <sound/asound.h>
+#include <sound/msm-dts-eagle.h>
 #include "msm-dts-srs-tm-config.h"
 #include "msm-pcm-routing-v2.h"
 
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-routing-devdep.c b/sound/soc/msm/qdsp6v2/msm-pcm-routing-devdep.c
index da177c99..60eb6f80 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-devdep.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-devdep.c
@@ -14,6 +14,8 @@
 #include <linux/module.h>
 #include <sound/hwdep.h>
 #include <sound/devdep_params.h>
+#include <sound/msm-dts-eagle.h>
+
 #include "msm-pcm-routing-devdep.h"
 #include "msm-ds2-dap-config.h"
 
@@ -51,6 +53,23 @@ static int msm_pcm_routing_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 	case SNDRV_DEVDEP_DAP_IOCTL_GET_VISUALIZER:
 		ret = msm_ds2_dap_ioctl(hw, file, cmd, argp);
 		break;
+	case DTS_EAGLE_IOCTL_GET_CACHE_SIZE:
+	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE:
+	case DTS_EAGLE_IOCTL_GET_PARAM:
+	case DTS_EAGLE_IOCTL_SET_PARAM:
+	case DTS_EAGLE_IOCTL_SET_CACHE_BLOCK:
+	case DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE:
+	case DTS_EAGLE_IOCTL_GET_LICENSE:
+	case DTS_EAGLE_IOCTL_SET_LICENSE:
+	case DTS_EAGLE_IOCTL_SEND_LICENSE:
+	case DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS:
+		ret = msm_dts_eagle_ioctl(cmd, arg);
+		if (ret == -EPERM) {
+			pr_err("%s called with invalid control 0x%X\n",
+				__func__, cmd);
+			ret = -EINVAL;
+		}
+		break;
 	default:
 		pr_err("%s called with invalid control 0x%X\n", __func__, cmd);
 		ret = -EINVAL;
@@ -62,6 +81,7 @@ static int msm_pcm_routing_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 void msm_pcm_routing_hwdep_free(struct snd_pcm *pcm)
 {
 	pr_debug("%s\n", __func__);
+	msm_dts_eagle_pcm_free(pcm);
 }
 
 #ifdef CONFIG_COMPAT
@@ -85,6 +105,23 @@ static int msm_pcm_routing_hwdep_compat_ioctl(struct snd_hwdep *hw,
 	case SNDRV_DEVDEP_DAP_IOCTL_GET_VISUALIZER32:
 		ret = msm_ds2_dap_compat_ioctl(hw, file, cmd, argp);
 		break;
+	case DTS_EAGLE_IOCTL_GET_CACHE_SIZE32:
+	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE32:
+	case DTS_EAGLE_IOCTL_GET_PARAM32:
+	case DTS_EAGLE_IOCTL_SET_PARAM32:
+	case DTS_EAGLE_IOCTL_SET_CACHE_BLOCK32:
+	case DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE32:
+	case DTS_EAGLE_IOCTL_GET_LICENSE32:
+	case DTS_EAGLE_IOCTL_SET_LICENSE32:
+	case DTS_EAGLE_IOCTL_SEND_LICENSE32:
+	case DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS32:
+		ret = msm_dts_eagle_compat_ioctl(cmd, arg);
+		if (ret == -EPERM) {
+			pr_err("%s called with invalid control 0x%X\n",
+				__func__, cmd);
+			ret = -EINVAL;
+		}
+		break;
 	default:
 		pr_err("%s called with invalid control 0x%X\n", __func__, cmd);
 		ret = -EINVAL;
@@ -130,6 +167,6 @@ int msm_pcm_routing_hwdep_new(struct snd_soc_pcm_runtime *runtime,
 #ifdef CONFIG_COMPAT
 	hwdep->ops.ioctl_compat = msm_pcm_routing_hwdep_compat_ioctl;
 #endif
-	return rc;
+	return msm_dts_eagle_pcm_new(runtime);
 }
 #endif
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
index 5f2b0f17..982fd513 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
@@ -33,6 +33,7 @@
 #include <sound/pcm_params.h>
 #include <sound/q6core.h>
 #include <sound/audio_cal_utils.h>
+#include <sound/msm-dts-eagle.h>
 #include <sound/audio_effects.h>
 #include <sound/hwdep.h>
 #include "msm-pcm-routing-v2.h"
@@ -192,6 +193,10 @@ static void msm_pcm_routing_cfg_pp(int port_id, int copp_idx, int topology,
 					__func__, topology, port_id, rc);
 		}
 		break;
+	case ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX:
+		pr_debug("%s: DTS_EAGLE_COPP_TOPOLOGY_ID\n", __func__);
+		msm_dts_eagle_init_post(port_id, copp_idx);
+		break;
 	case ADM_CMD_COPP_OPEN_TOPOLOGY_ID_AUDIOSPHERE:
 		pr_debug("%s: TOPOLOGY_ID_AUDIOSPHERE\n", __func__);
 		msm_qti_pp_asphere_init(port_id, copp_idx);
@@ -223,6 +228,10 @@ static void msm_pcm_routing_deinit_pp(int port_id, int topology)
 			msm_dolby_dap_deinit(port_id);
 		}
 		break;
+	case ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX:
+		pr_debug("%s: DTS_EAGLE_COPP_TOPOLOGY_ID\n", __func__);
+		msm_dts_eagle_deinit_post(port_id, topology);
+		break;
 	case ADM_CMD_COPP_OPEN_TOPOLOGY_ID_AUDIOSPHERE:
 		pr_debug("%s: TOPOLOGY_ID_AUDIOSPHERE\n", __func__);
 		msm_qti_pp_asphere_deinit(port_id);
@@ -13602,6 +13611,8 @@ static int msm_routing_probe(struct snd_soc_platform *platform)
 				device_pp_params_mixer_controls,
 				ARRAY_SIZE(device_pp_params_mixer_controls));
 
+	msm_dts_eagle_add_controls(platform);
+
 	snd_soc_add_platform_controls(platform, msm_source_tracking_controls,
 				      ARRAY_SIZE(msm_source_tracking_controls));
 
diff --git a/sound/soc/msm/qdsp6v2/q6adm.c b/sound/soc/msm/qdsp6v2/q6adm.c
index ad0a27ec..6853af81 100644
--- a/sound/soc/msm/qdsp6v2/q6adm.c
+++ b/sound/soc/msm/qdsp6v2/q6adm.c
@@ -23,6 +23,7 @@
 #include <sound/q6afe-v2.h>
 #include <sound/audio_cal_utils.h>
 #include <sound/asound.h>
+#include <sound/msm-dts-eagle.h>
 #include "msm-dts-srs-tm-config.h"
 #include <sound/adsp_err.h>
 #define TIMEOUT_MS 1000
@@ -254,6 +255,222 @@ static int adm_get_next_available_copp(int port_idx)
 	return idx;
 }
 
+int adm_dts_eagle_set(int port_id, int copp_idx, int param_id,
+		      void *data, uint32_t size)
+{
+	struct adm_cmd_set_pp_params_v5	admp;
+	int p_idx, ret = 0, *ob_params;
+
+	pr_debug("DTS_EAGLE_ADM: %s - port id %i, copp idx %i, param id 0x%X size %u\n",
+		__func__, port_id, copp_idx, param_id, size);
+
+	port_id = afe_convert_virtual_to_portid(port_id);
+	p_idx = adm_validate_and_get_port_index(port_id);
+	pr_debug("DTS_EAGLE_ADM: %s - after lookup, port id %i, port idx %i\n",
+		__func__, port_id, p_idx);
+
+	if (p_idx < 0) {
+		pr_err("DTS_EAGLE_ADM: %s: invalid port index 0x%x, port id 0x%x\n",
+			__func__, p_idx, port_id);
+		return -EINVAL;
+	}
+
+	if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
+		pr_err("DTS_EAGLE_ADM: %s: Invalid copp_idx: %d\n", __func__,
+			copp_idx);
+		return -EINVAL;
+	}
+
+	ob_params = (int *)this_adm.outband_memmap.kvaddr;
+	if (ob_params == NULL) {
+		pr_err("DTS_EAGLE_ADM: %s - NULL memmap. Non Eagle topology selected?\n",
+			__func__);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	/* check for integer overflow */
+	if (size > (UINT_MAX - APR_CMD_OB_HDR_SZ))
+		ret = -EINVAL;
+	if ((ret < 0) ||
+	    (size + APR_CMD_OB_HDR_SZ > this_adm.outband_memmap.size)) {
+		pr_err("DTS_EAGLE_ADM - %s: ion alloc of size %zu too small for size requested %u\n",
+			__func__, this_adm.outband_memmap.size,
+			size + APR_CMD_OB_HDR_SZ);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	*ob_params++ = AUDPROC_MODULE_ID_DTS_HPX_POSTMIX;
+	*ob_params++ = param_id;
+	*ob_params++ = size;
+	memcpy(ob_params, data, size);
+
+	admp.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+		APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	admp.hdr.pkt_size = sizeof(admp);
+	admp.hdr.src_svc = APR_SVC_ADM;
+	admp.hdr.src_domain = APR_DOMAIN_APPS;
+	admp.hdr.src_port = port_id;
+	admp.hdr.dest_svc = APR_SVC_ADM;
+	admp.hdr.dest_domain = APR_DOMAIN_ADSP;
+	admp.hdr.dest_port = atomic_read(&this_adm.copp.id[p_idx][copp_idx]);
+	admp.hdr.token = p_idx << 16 | copp_idx;
+	admp.hdr.opcode = ADM_CMD_SET_PP_PARAMS_V5;
+	admp.payload_addr_lsw = lower_32_bits(this_adm.outband_memmap.paddr);
+	admp.payload_addr_msw = msm_audio_populate_upper_32_bits(
+						this_adm.outband_memmap.paddr);
+	admp.mem_map_handle = atomic_read(&this_adm.mem_map_handles[
+					  ADM_DTS_EAGLE]);
+	admp.payload_size = size + sizeof(struct adm_param_data_v5);
+
+	pr_debug("DTS_EAGLE_ADM: %s - Command was sent now check Q6 - port id = %d, size %d, module id %x, param id %x.\n",
+			__func__, admp.hdr.dest_port,
+			admp.payload_size, AUDPROC_MODULE_ID_DTS_HPX_POSTMIX,
+			param_id);
+	atomic_set(&this_adm.copp.stat[p_idx][copp_idx], -1);
+	ret = apr_send_pkt(this_adm.apr, (uint32_t *)&admp);
+	if (ret < 0) {
+		pr_err("DTS_EAGLE_ADM: %s - ADM enable for port %d failed\n",
+			__func__, port_id);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	ret = wait_event_timeout(this_adm.copp.wait[p_idx][copp_idx],
+			atomic_read(&this_adm.copp.stat
+			[p_idx][copp_idx]) >= 0,
+			msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("DTS_EAGLE_ADM: %s - set params timed out port = %d\n",
+			__func__, port_id);
+		ret = -EINVAL;
+	} else if (atomic_read(&this_adm.copp.stat
+				[p_idx][copp_idx]) > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				atomic_read(&this_adm.copp.stat
+				[p_idx][copp_idx])));
+		ret = adsp_err_get_lnx_err_code(
+				atomic_read(&this_adm.copp.stat
+				[p_idx][copp_idx]));
+	} else {
+		ret = 0;
+	}
+
+fail_cmd:
+	return ret;
+}
+
+int adm_dts_eagle_get(int port_id, int copp_idx, int param_id,
+		      void *data, uint32_t size)
+{
+	struct adm_cmd_get_pp_params_v5	admp;
+	int p_idx, ret = 0, *ob_params;
+	uint32_t orig_size = size;
+	pr_debug("DTS_EAGLE_ADM: %s - port id %i, copp idx %i, param id 0x%X\n",
+		 __func__, port_id, copp_idx, param_id);
+
+	port_id = afe_convert_virtual_to_portid(port_id);
+	p_idx = adm_validate_and_get_port_index(port_id);
+	if (p_idx < 0) {
+		pr_err("DTS_EAGLE_ADM: %s - invalid port index %i, port id %i, copp idx %i\n",
+				__func__, p_idx, port_id, copp_idx);
+		return -EINVAL;
+	}
+
+	if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
+		pr_err("DTS_EAGLE_ADM: %s: Invalid copp_idx: %d\n", __func__,
+			copp_idx);
+		return -EINVAL;
+	}
+
+	if ((size == 0) || !data) {
+		pr_err("DTS_EAGLE_ADM: %s - invalid size %u or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+
+	size = (size+3) & 0xFFFFFFFC;
+
+	ob_params = (int *)(this_adm.outband_memmap.kvaddr);
+	if (ob_params == NULL) {
+		pr_err("DTS_EAGLE_ADM: %s - NULL memmap. Non Eagle topology selected?",
+			__func__);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	/* check for integer overflow */
+	if (size > (UINT_MAX - APR_CMD_OB_HDR_SZ))
+		ret = -EINVAL;
+	if ((ret < 0) ||
+	    (size + APR_CMD_OB_HDR_SZ > this_adm.outband_memmap.size)) {
+		pr_err("DTS_EAGLE_ADM - %s: ion alloc of size %zu too small for size requested %u\n",
+			__func__, this_adm.outband_memmap.size,
+			size + APR_CMD_OB_HDR_SZ);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	*ob_params++ = AUDPROC_MODULE_ID_DTS_HPX_POSTMIX;
+	*ob_params++ = param_id;
+	*ob_params++ = size;
+
+	admp.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+			     APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	admp.hdr.pkt_size = sizeof(admp);
+	admp.hdr.src_svc = APR_SVC_ADM;
+	admp.hdr.src_domain = APR_DOMAIN_APPS;
+	admp.hdr.src_port = port_id;
+	admp.hdr.dest_svc = APR_SVC_ADM;
+	admp.hdr.dest_domain = APR_DOMAIN_ADSP;
+	admp.hdr.dest_port = atomic_read(&this_adm.copp.id[p_idx][copp_idx]);
+	admp.hdr.token = p_idx << 16 | copp_idx;
+	admp.hdr.opcode = ADM_CMD_GET_PP_PARAMS_V5;
+	admp.data_payload_addr_lsw =
+				lower_32_bits(this_adm.outband_memmap.paddr);
+	admp.data_payload_addr_msw =
+				msm_audio_populate_upper_32_bits(
+						this_adm.outband_memmap.paddr);
+	admp.mem_map_handle = atomic_read(&this_adm.mem_map_handles[
+					  ADM_DTS_EAGLE]);
+	admp.module_id = AUDPROC_MODULE_ID_DTS_HPX_POSTMIX;
+	admp.param_id = param_id;
+	admp.param_max_size = size + sizeof(struct adm_param_data_v5);
+	admp.reserved = 0;
+
+	atomic_set(&this_adm.copp.stat[p_idx][copp_idx], -1);
+
+	ret = apr_send_pkt(this_adm.apr, (uint32_t *)&admp);
+	if (ret < 0) {
+		pr_err("DTS_EAGLE_ADM: %s - Failed to get EAGLE Params on port %d\n",
+			__func__, port_id);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	ret = wait_event_timeout(this_adm.copp.wait[p_idx][copp_idx],
+			atomic_read(&this_adm.copp.stat
+			[p_idx][copp_idx]) >= 0,
+			msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("DTS_EAGLE_ADM: %s - EAGLE get params timed out port = %d\n",
+			__func__, port_id);
+		ret = -EINVAL;
+		goto fail_cmd;
+	} else if (atomic_read(&this_adm.copp.stat
+				[p_idx][copp_idx]) > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				atomic_read(&this_adm.copp.stat
+				[p_idx][copp_idx])));
+		ret = adsp_err_get_lnx_err_code(
+				atomic_read(&this_adm.copp.stat
+					[p_idx][copp_idx]));
+		goto fail_cmd;
+	}
+
+	memcpy(data, ob_params, orig_size);
+	ret = 0;
+fail_cmd:
+	return ret;
+}
+
 int srs_trumedia_open(int port_id, int copp_idx, __s32 srs_tech_id,
 		      void *srs_params)
 {
@@ -2393,6 +2610,13 @@ int adm_open(int port_id, int path, int rate, int channel_mode, int topology,
 		 __func__, port_id, path, rate, channel_mode, perf_mode,
 		 topology);
 
+	/* For DTS EAGLE only, force 24 bit */
+	if ((topology == ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX) &&
+		(perf_mode == LEGACY_PCM_MODE)) {
+		bit_width = 24;
+		pr_debug("%s: Force open adm in 24-bit for DTS HPX topology 0x%x\n",
+			__func__, topology);
+	}
 	port_id = q6audio_convert_virtual_to_portid(port_id);
 	port_idx = adm_validate_and_get_port_index(port_id);
 	if (port_idx < 0) {
@@ -2499,6 +2723,20 @@ int adm_open(int port_id, int path, int rate, int channel_mode, int topology,
 		(uint32_t)this_adm.outband_memmap.size);
 		}
 	}
+		if ((topology == ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX) &&
+		    (perf_mode == LEGACY_PCM_MODE)) {
+			int res = 0;
+			atomic_set(&this_adm.mem_map_index, ADM_DTS_EAGLE);
+			msm_dts_ion_memmap(&this_adm.outband_memmap);
+			res = adm_memory_map_regions(
+				      &this_adm.outband_memmap.paddr,
+				      0,
+				      (uint32_t *)&this_adm.outband_memmap.size,
+				      1);
+			if (res < 0)
+				pr_err("%s: DTS_EAGLE mmap did not work!",
+					__func__);
+		}
 		open.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
 						   APR_HDR_LEN(APR_HDR_SIZE),
 						   APR_PKT_VER);
@@ -2954,6 +3192,21 @@ int adm_close(int port_id, int perf_mode, int copp_idx)
 			}
 		}
 
+		if ((perf_mode == LEGACY_PCM_MODE) &&
+		    (this_adm.outband_memmap.paddr != 0) &&
+		    (atomic_read(
+			&this_adm.copp.topology[port_idx][copp_idx]) ==
+			ADM_CMD_COPP_OPEN_TOPOLOGY_ID_DTS_HPX)) {
+			atomic_set(&this_adm.mem_map_index, ADM_DTS_EAGLE);
+			ret = adm_memory_unmap_regions();
+			if (ret < 0) {
+				pr_err("%s: adm mem unmmap err %d",
+					__func__, ret);
+			} else {
+				atomic_set(&this_adm.mem_map_handles
+					   [ADM_DTS_EAGLE], 0);
+			}
+		}
 
 		if ((afe_get_port_type(port_id) == MSM_AFE_PORT_TYPE_TX) &&
 		    this_adm.sourceTrackingData.memmap.paddr) {
@@ -3426,6 +3679,10 @@ static int adm_init_cal_data(void)
 		{NULL, NULL, NULL, NULL, NULL, NULL} },
 		{NULL, NULL, cal_utils_match_buf_num} },
 
+		{{DTS_EAGLE_CAL_TYPE,
+		{NULL, NULL, NULL, NULL, NULL, NULL} },
+		{NULL, NULL, cal_utils_match_buf_num} },
+
 		{{SRS_TRUMEDIA_CAL_TYPE,
 		{NULL, NULL, NULL, NULL, NULL, NULL} },
 		{NULL, NULL, cal_utils_match_buf_num} },
diff --git a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
index aef23da3..b668c21a 100644
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@ -38,6 +38,7 @@
 #include <sound/q6asm-v2.h>
 #include <sound/q6audio-v2.h>
 #include <sound/audio_cal_utils.h>
+#include <sound/msm-dts-eagle.h>
 #include <sound/adsp_err.h>
 #include <sound/compress_params.h>
 
@@ -2635,6 +2636,11 @@ static int __q6asm_open_write(struct audio_client *ac, uint32_t format,
 
 	open.postprocopo_id = q6asm_get_asm_topology_cal();
 
+	/* For DTS EAGLE only, force 24 bit */
+	if ((open.postprocopo_id == ASM_STREAM_POSTPROC_TOPO_ID_DTS_HPX) ||
+	     (open.postprocopo_id == ASM_STREAM_POSTPROC_TOPO_ID_HPX_PLUS))
+		open.bits_per_sample = 24;
+
 	pr_debug("%s: perf_mode %d asm_topology 0x%x bps %d\n", __func__,
 		 ac->perf_mode, open.postprocopo_id, open.bits_per_sample);
 
@@ -2821,6 +2827,10 @@ static int __q6asm_open_read_write(struct audio_client *ac, uint32_t rd_format,
 	ac->topology = open.postprocopo_id;
 	ac->app_type = q6asm_get_asm_app_type_cal();
 
+	/* For DTS EAGLE only, force 24 bit */
+	if ((open.postprocopo_id == ASM_STREAM_POSTPROC_TOPO_ID_DTS_HPX) ||
+	     (open.postprocopo_id == ASM_STREAM_POSTPROC_TOPO_ID_HPX_MASTER))
+		open.bits_per_sample = 24;
 
 	switch (wr_format) {
 	case FORMAT_LINEAR_PCM:
@@ -6096,6 +6106,233 @@ fail_cmd:
 	return rc;
 }
 
+int q6asm_dts_eagle_set(struct audio_client *ac, int param_id, uint32_t size,
+			void *data, struct param_outband *po, int m_id)
+{
+	int rc = 0, *ob_params = NULL;
+	uint32_t sz = sizeof(struct asm_dts_eagle_param) + (po ? 0 : size);
+	struct asm_dts_eagle_param *ad;
+
+	if (!ac || ac->apr == NULL || (size == 0) || !data) {
+		pr_err("DTS_EAGLE_ASM - %s: APR handle NULL, invalid size %u or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+
+	ad = kzalloc(sz, GFP_KERNEL);
+	if (!ad) {
+		pr_err("DTS_EAGLE_ASM - %s: error allocating mem of size %u\n",
+			__func__, sz);
+		return -ENOMEM;
+	}
+	pr_debug("DTS_EAGLE_ASM - %s: ac %pK param_id 0x%x size %u data %pK m_id 0x%x\n",
+		__func__, ac, param_id, size, data, m_id);
+	q6asm_add_hdr_async(ac, &ad->hdr, sz, 1);
+	ad->hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
+	ad->param.data_payload_addr_lsw = 0;
+	ad->param.data_payload_addr_msw = 0;
+
+	ad->param.mem_map_handle = 0;
+	ad->param.data_payload_size = size +
+					sizeof(struct asm_stream_param_data_v2);
+	ad->data.module_id = m_id;
+	ad->data.param_id = param_id;
+	ad->data.param_size = size;
+	ad->data.reserved = 0;
+	atomic_set(&ac->cmd_state, -1);
+
+	if (po) {
+		struct list_head *ptr, *next;
+		struct asm_buffer_node *node;
+		pr_debug("DTS_EAGLE_ASM - %s: using out of band memory (virtual %pK, physical %pK)\n",
+			__func__, po->kvaddr, &po->paddr);
+		ad->param.data_payload_addr_lsw = lower_32_bits(po->paddr);
+		ad->param.data_payload_addr_msw =
+				msm_audio_populate_upper_32_bits(po->paddr);
+		list_for_each_safe(ptr, next, &ac->port[IN].mem_map_handle) {
+			node = list_entry(ptr, struct asm_buffer_node, list);
+			if (node->buf_phys_addr == po->paddr) {
+				ad->param.mem_map_handle = node->mmap_hdl;
+				break;
+			}
+		}
+		if (ad->param.mem_map_handle == 0) {
+			pr_err("DTS_EAGLE_ASM - %s: mem map handle not found\n",
+				__func__);
+			rc = -EINVAL;
+			goto fail_cmd;
+		}
+		/* check for integer overflow */
+		if (size > (UINT_MAX - APR_CMD_OB_HDR_SZ))
+			rc = -EINVAL;
+		if ((rc < 0) || (size + APR_CMD_OB_HDR_SZ > po->size)) {
+			pr_err("DTS_EAGLE_ASM - %s: ion alloc of size %zu too small for size requested %u\n",
+				__func__, po->size, size + APR_CMD_OB_HDR_SZ);
+			rc = -EINVAL;
+			goto fail_cmd;
+		}
+		ob_params = (int *)po->kvaddr;
+		*ob_params++ = m_id;
+		*ob_params++ = param_id;
+		*ob_params++ = size;
+		memcpy(ob_params, data, size);
+	} else {
+		pr_debug("DTS_EAGLE_ASM - %s: using in band\n", __func__);
+		memcpy(((char *)ad) + sizeof(struct asm_dts_eagle_param),
+			data, size);
+	}
+	rc = apr_send_pkt(ac->apr, (uint32_t *)ad);
+	if (rc < 0) {
+		pr_err("DTS_EAGLE_ASM - %s: set-params send failed paramid[0x%x]\n",
+			__func__, ad->data.param_id);
+		rc = -EINVAL;
+		goto fail_cmd;
+	}
+
+	rc = wait_event_timeout(ac->cmd_wait,
+			(atomic_read(&ac->cmd_state) >= 0), 1*HZ);
+	if (!rc) {
+		pr_err("DTS_EAGLE_ASM - %s: timeout, set-params paramid[0x%x]\n",
+			__func__, ad->data.param_id);
+		rc = -ETIMEDOUT;
+		goto fail_cmd;
+	}
+
+	if (atomic_read(&ac->cmd_state) > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				atomic_read(&ac->cmd_state)));
+		rc = adsp_err_get_lnx_err_code(
+				atomic_read(&ac->cmd_state));
+		goto fail_cmd;
+	}
+	rc = 0;
+fail_cmd:
+	kfree(ad);
+	return rc;
+}
+
+int q6asm_dts_eagle_get(struct audio_client *ac, int param_id, uint32_t size,
+			void *data, struct param_outband *po, int m_id)
+{
+	struct asm_dts_eagle_param_get *ad;
+	int rc = 0, *ob_params = NULL;
+	uint32_t sz = sizeof(struct asm_dts_eagle_param) + APR_CMD_GET_HDR_SZ +
+		 (po ? 0 : size);
+
+	if (!ac || ac->apr == NULL || (size == 0) || !data) {
+		pr_err("DTS_EAGLE_ASM - %s: APR handle NULL, invalid size %u or pointer %pK\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+	ad = kzalloc(sz, GFP_KERNEL);
+	if (!ad) {
+		pr_err("DTS_EAGLE_ASM - %s: error allocating memory of size %u\n",
+			__func__, sz);
+		return -ENOMEM;
+	}
+	pr_debug("DTS_EAGLE_ASM - %s: ac %pK param_id 0x%x size %u data %pK m_id 0x%x\n",
+		__func__, ac, param_id, size, data, m_id);
+	q6asm_add_hdr(ac, &ad->hdr, sz, TRUE);
+	ad->hdr.opcode = ASM_STREAM_CMD_GET_PP_PARAMS_V2;
+	ad->param.data_payload_addr_lsw = 0;
+	ad->param.data_payload_addr_msw = 0;
+	ad->param.mem_map_handle = 0;
+	ad->param.module_id = m_id;
+	ad->param.param_id = param_id;
+	ad->param.param_max_size = size + APR_CMD_GET_HDR_SZ;
+	ad->param.reserved = 0;
+	atomic_set(&ac->cmd_state, -1);
+
+	generic_get_data = kzalloc(size + sizeof(struct generic_get_data_),
+				   GFP_KERNEL);
+	if (!generic_get_data) {
+		pr_err("DTS_EAGLE_ASM - %s: error allocating mem of size %u\n",
+			__func__, size);
+		rc = -ENOMEM;
+		goto fail_cmd;
+	}
+
+	if (po) {
+		struct list_head *ptr, *next;
+		struct asm_buffer_node *node;
+		pr_debug("DTS_EAGLE_ASM - %s: using out of band memory (virtual %pK, physical %pK)\n",
+			 __func__, po->kvaddr, &po->paddr);
+		ad->param.data_payload_addr_lsw = lower_32_bits(po->paddr);
+		ad->param.data_payload_addr_msw =
+				msm_audio_populate_upper_32_bits(po->paddr);
+		list_for_each_safe(ptr, next, &ac->port[IN].mem_map_handle) {
+			node = list_entry(ptr, struct asm_buffer_node, list);
+			if (node->buf_phys_addr == po->paddr) {
+				ad->param.mem_map_handle = node->mmap_hdl;
+				break;
+			}
+		}
+		if (ad->param.mem_map_handle == 0) {
+			pr_err("DTS_EAGLE_ASM - %s: mem map handle not found\n",
+				__func__);
+			rc = -EINVAL;
+			goto fail_cmd;
+		}
+		/* check for integer overflow */
+		if (size > (UINT_MAX - APR_CMD_OB_HDR_SZ))
+			rc = -EINVAL;
+		if ((rc < 0) || (size + APR_CMD_OB_HDR_SZ > po->size)) {
+			pr_err("DTS_EAGLE_ASM - %s: ion alloc of size %zu too small for size requested %u\n",
+				__func__, po->size, size + APR_CMD_OB_HDR_SZ);
+			rc = -EINVAL;
+			goto fail_cmd;
+		}
+		ob_params = (int *)po->kvaddr;
+		*ob_params++ = m_id;
+		*ob_params++ = param_id;
+		*ob_params++ = size;
+		generic_get_data->is_inband = 0;
+	} else {
+		pr_debug("DTS_EAGLE_ASM - %s: using in band\n", __func__);
+		generic_get_data->is_inband = 1;
+	}
+
+	rc = apr_send_pkt(ac->apr, (uint32_t *)ad);
+	if (rc < 0) {
+		pr_err("DTS_EAGLE_ASM - %s: Commmand 0x%x failed\n", __func__,
+			ad->hdr.opcode);
+		goto fail_cmd;
+	}
+
+	rc = wait_event_timeout(ac->cmd_wait,
+			(atomic_read(&ac->cmd_state) >= 0), 1*HZ);
+	if (!rc) {
+		pr_err("DTS_EAGLE_ASM - %s: timeout in get\n",
+			__func__);
+		rc = -ETIMEDOUT;
+		goto fail_cmd;
+	}
+
+	if (atomic_read(&ac->cmd_state) > 0) {
+		pr_err("%s: DSP returned error[%s]\n",
+				__func__, adsp_err_get_err_str(
+				atomic_read(&ac->cmd_state)));
+		rc = adsp_err_get_lnx_err_code(
+				atomic_read(&ac->cmd_state));
+		goto fail_cmd;
+	}
+
+	if (generic_get_data->valid) {
+		rc = 0;
+		memcpy(data, po ? ob_params : generic_get_data->ints, size);
+	} else {
+		rc = -EINVAL;
+		pr_err("DTS_EAGLE_ASM - %s: EAGLE get params problem getting data - check callback error value\n",
+			__func__);
+	}
+fail_cmd:
+	kfree(ad);
+	kfree(generic_get_data);
+	generic_get_data = NULL;
+	return rc;
+}
+
 static int __q6asm_set_volume(struct audio_client *ac, int volume, int instance)
 {
 	struct asm_volume_ctrl_master_gain vol;
diff --git a/sound/soc/msm/qdsp6v2/q6core.c b/sound/soc/msm/qdsp6v2/q6core.c
index 3fedc869..3fbf251c 100644
--- a/sound/soc/msm/qdsp6v2/q6core.c
+++ b/sound/soc/msm/qdsp6v2/q6core.c
@@ -203,7 +203,7 @@ static int32_t aprv2_core_fn_q(struct apr_client_data *data, void *priv)
 			generic_get_data->valid = 1;
 			generic_get_data->size_in_ints =
 				data->payload_size/sizeof(int);
-			pr_debug("callback size = %i\n",
+			pr_debug("DTS_EAGLE_CORE callback size = %i\n",
 				 data->payload_size);
 			memcpy(generic_get_data->ints, data->payload,
 				data->payload_size);
@@ -479,6 +479,115 @@ fail_cmd:
 	return ret;
 }
 
+int core_dts_eagle_set(int size, char *data)
+{
+	struct adsp_dts_eagle *payload = NULL;
+	int rc = 0, size_aligned4byte;
+
+	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
+	if (size <= 0 || !data) {
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+
+	size_aligned4byte = (size+3) & 0xFFFFFFFC;
+	ocm_core_open();
+	if (q6core_lcl.core_handle_q) {
+		payload = kzalloc(sizeof(struct adsp_dts_eagle) +
+				  size_aligned4byte, GFP_KERNEL);
+		if (!payload) {
+			pr_err("DTS_EAGLE_CORE - %s: out of memory (aligned size %i).\n",
+				__func__, size_aligned4byte);
+			return -ENOMEM;
+		}
+		payload->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_EVENT,
+						APR_HDR_LEN(APR_HDR_SIZE),
+						APR_PKT_VER);
+		payload->hdr.pkt_size = sizeof(struct adsp_dts_eagle) +
+					       size_aligned4byte;
+		payload->hdr.src_port = 0;
+		payload->hdr.dest_port = 0;
+		payload->hdr.token = 0;
+		payload->hdr.opcode = ADSP_CMD_SET_DTS_EAGLE_DATA_ID;
+		payload->id = DTS_EAGLE_LICENSE_ID;
+		payload->overwrite = 1;
+		payload->size = size;
+		memcpy(payload->data, data, size);
+		rc = apr_send_pkt(q6core_lcl.core_handle_q,
+				(uint32_t *)payload);
+		if (rc < 0) {
+			pr_err("DTS_EAGLE_CORE - %s: failed op[0x%x]rc[%d]\n",
+				__func__, payload->hdr.opcode, rc);
+		}
+		kfree(payload);
+	}
+	return rc;
+}
+
+int core_dts_eagle_get(int id, int size, char *data)
+{
+	struct apr_hdr ah;
+	int rc = 0;
+
+	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
+	if (size <= 0 || !data) {
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+	ocm_core_open();
+	if (q6core_lcl.core_handle_q) {
+		ah.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_EVENT,
+				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+		ah.pkt_size = sizeof(struct apr_hdr);
+		ah.src_port = 0;
+		ah.dest_port = 0;
+		ah.token = 0;
+		ah.opcode = id;
+
+		q6core_lcl.bus_bw_resp_received = 0;
+		generic_get_data = kzalloc(sizeof(struct generic_get_data_)
+					   + size, GFP_KERNEL);
+		if (!generic_get_data) {
+			pr_err("DTS_EAGLE_CORE - %s: error allocating memory of size %i\n",
+				__func__, size);
+			return -ENOMEM;
+		}
+
+		rc = apr_send_pkt(q6core_lcl.core_handle_q,
+				(uint32_t *)&ah);
+		if (rc < 0) {
+			pr_err("DTS_EAGLE_CORE - %s: failed op[0x%x]rc[%d]\n",
+				__func__, ah.opcode, rc);
+			goto fail_cmd_2;
+		}
+
+		rc = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+		if (!rc) {
+			pr_err("DTS_EAGLE_CORE - %s: EAGLE get params timed out\n",
+				__func__);
+			rc = -EINVAL;
+			goto fail_cmd_2;
+		}
+		if (generic_get_data->valid) {
+			rc = 0;
+			memcpy(data, generic_get_data->ints, size);
+		} else {
+			rc = -EINVAL;
+			pr_err("DTS_EAGLE_CORE - %s: EAGLE get params problem getting data - check callback error value\n",
+				__func__);
+		}
+	}
+
+fail_cmd_2:
+	kfree(generic_get_data);
+	generic_get_data = NULL;
+	return rc;
+}
+
 uint32_t core_set_dolby_manufacturer_id(int manufacturer_id)
 {
 	struct adsp_dolby_manufacturer_id payload;
-- 
2.11.0

